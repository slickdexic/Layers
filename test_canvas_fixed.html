<!DOCTYPE html>
<html>
<head>
    <title>Layers Extension - Fixed Canvas Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            border: 1px solid #ddd;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .layers-editor {
            border: 2px solid #007bff;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        .layers-toolbar {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 10px;
        }
        .layers-content {
            display: flex;
            height: 500px;
        }
        .layers-panel {
            width: 250px;
            border-right: 1px solid #dee2e6;
            background: #f8f9fa;
            padding: 10px;
            overflow-y: auto;
        }
        .layers-canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            position: relative;
            overflow: auto;
        }
        .layers-canvas {
            border: 1px solid #dee2e6;
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        .test-controls {
            margin: 10px 0;
        }
        .test-controls button {
            margin: 5px;
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .test-controls button:hover {
            background: #0056b3;
        }
        .test-controls button.active {
            background: #28a745;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .test-result.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-result.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .status-panel {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Layers Extension - Fixed Canvas Test</h1>
    <p>This is a comprehensive test of the Layers extension functionality with proper error handling and debugging.</p>

    <div class="test-container">
        <h2>Loading Status</h2>
        <div id="loading-status" class="loading">Initializing...</div>
        <div id="status-panel" class="status-panel"></div>
    </div>

    <div class="test-container">
        <h2>Tool Selection</h2>
        <div class="test-controls">
            <button onclick="selectTool('pointer')" id="btn-pointer">üëÜ Select (V)</button>
            <button onclick="selectTool('text')" id="btn-text">üìù Text (T)</button>
            <button onclick="selectTool('rectangle')" id="btn-rectangle">‚óªÔ∏è Rectangle (R)</button>
            <button onclick="selectTool('circle')" id="btn-circle">‚≠ï Circle (C)</button>
            <button onclick="selectTool('line')" id="btn-line">üìè Line (L)</button>
            <button onclick="selectTool('arrow')" id="btn-arrow">‚û°Ô∏è Arrow (A)</button>
            <button onclick="selectTool('pen')" id="btn-pen">‚úèÔ∏è Pen (P)</button>
            <button onclick="selectTool('highlight')" id="btn-highlight">üñçÔ∏è Highlight (H)</button>
        </div>
        
        <div class="test-controls">
            <label>Color: <input type="color" id="color-picker" value="#ff0000" onchange="updateStyle()"></label>
            <label>Font Size: <input type="number" id="size-input" value="16" min="8" max="72" onchange="updateStyle()"></label>
            <label>Line Width: <input type="number" id="width-input" value="3" min="1" max="20" onchange="updateStyle()"></label>
        </div>
    </div>

    <div class="test-container">
        <h2>Editor Interface</h2>
        <div id="editor-container">
            <div class="loading">Loading editor components...</div>
        </div>
    </div>

    <div class="test-container">
        <h2>Controls</h2>
        <div class="test-controls">
            <button onclick="testUndo()">‚Ü∂ Undo</button>
            <button onclick="testRedo()">‚Ü∑ Redo</button>
            <button onclick="testClear()">üóëÔ∏è Clear All</button>
            <button onclick="testExport()">üíæ Export</button>
            <button onclick="testZoomIn()">üîç+ Zoom In</button>
            <button onclick="testZoomOut()">üîç- Zoom Out</button>
            <button onclick="testFitWindow()">üìè Fit to Window</button>
        </div>
        
        <div id="test-results" class="test-result"></div>
    </div>

    <!-- Load JavaScript files in correct order -->
    <script>
        // Enhanced MediaWiki mock
        window.mw = {
            config: {
                data: {
                    'wgServer': 'http://localhost:8081',
                    'wgScriptPath': '',
                    'wgNamespaceNumber': 6,
                    'wgTitle': 'test-image.png',
                    'wgUserGroups': ['user']
                },
                get: function(key) {
                    return this.data[key] || '';
                }
            },
            Api: function() {
                return {
                    get: function(params) {
                        console.log('API GET:', params);
                        return { 
                            done: function(callback) { 
                                // Simulate empty layers response
                                setTimeout(() => callback({ layersinfo: { layerset: { data: { layers: [] } } } }), 100);
                                return this; 
                            },
                            fail: function(callback) { 
                                setTimeout(() => callback('API not available'), 100);
                                return this; 
                            }
                        };
                    },
                    postWithToken: function(token, params) {
                        console.log('API POST:', token, params);
                        return { 
                            done: function(callback) { 
                                setTimeout(() => callback({ layerssave: { success: true } }), 100);
                                return this; 
                            },
                            fail: function(callback) { 
                                setTimeout(() => callback('Save failed'), 100);
                                return this; 
                            }
                        };
                    }
                };
            },
            notify: function(msg, opts) {
                console.log('MW Notify:', msg, opts);
                showResult(msg, opts.type || 'success');
            },
            msg: function(key) {
                var messages = {
                    'layers-save-success': 'Layers saved successfully!',
                    'layers-save-error': 'Failed to save layers'
                };
                return messages[key] || key;
            },
            hook: function(name) {
                return {
                    add: function(callback) {
                        console.log('Hook registered:', name);
                        // Store hooks for later use
                        window.mwHooks = window.mwHooks || {};
                        window.mwHooks[name] = window.mwHooks[name] || [];
                        window.mwHooks[name].push(callback);
                    }
                };
            },
            loader: {
                using: function(modules) {
                    console.log('MW Loader using:', modules);
                    return Promise.resolve();
                }
            }
        };

        // Global state
        var editor = null;
        var initializationSteps = [];

        function logStep(step) {
            initializationSteps.push(new Date().toISOString() + ': ' + step);
            updateStatusPanel();
            console.log('STEP:', step);
        }

        function updateStatusPanel() {
            var panel = document.getElementById('status-panel');
            panel.innerHTML = initializationSteps.slice(-10).join('\n');
        }

        function showResult(message, type) {
            var resultsEl = document.getElementById('test-results');
            resultsEl.textContent = message;
            resultsEl.className = 'test-result ' + type;
            resultsEl.style.display = 'block';
            
            setTimeout(function() {
                resultsEl.style.display = 'none';
            }, 3000);
        }

        // Tool functions
        function selectTool(tool) {
            if (editor) {
                editor.setCurrentTool(tool);
                updateToolButtons();
                showResult('Selected tool: ' + tool, 'success');
            } else {
                showResult('Editor not ready', 'error');
            }
        }

        function updateToolButtons() {
            document.querySelectorAll('.test-controls button[id^="btn-"]').forEach(function(btn) {
                btn.classList.remove('active');
            });
            var activeBtn = document.getElementById('btn-' + (editor ? editor.currentTool : 'pointer'));
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        function updateStyle() {
            if (editor && editor.canvasManager) {
                var color = document.getElementById('color-picker').value;
                var fontSize = parseInt(document.getElementById('size-input').value);
                var strokeWidth = parseInt(document.getElementById('width-input').value);
                
                var style = {
                    color: color,
                    fontSize: fontSize,
                    strokeWidth: strokeWidth
                };
                
                editor.canvasManager.updateStyleOptions(style);
                showResult('Style updated', 'success');
            }
        }

        // Control functions
        function testUndo() {
            if (editor && editor.undo) {
                editor.undo();
                showResult('Undo executed', 'success');
            } else {
                showResult('Undo not available', 'error');
            }
        }

        function testRedo() {
            if (editor && editor.redo) {
                editor.redo();
                showResult('Redo executed', 'success');
            } else {
                showResult('Redo not available', 'error');
            }
        }

        function testClear() {
            if (editor) {
                editor.layers = [];
                editor.renderLayers();
                showResult('All layers cleared', 'success');
            } else {
                showResult('Editor not ready', 'error');
            }
        }

        function testExport() {
            if (editor) {
                var json = JSON.stringify(editor.layers, null, 2);
                console.log('Exported layers:', json);
                showResult('Layers exported to console (' + editor.layers.length + ' layers)', 'success');
            } else {
                showResult('Editor not ready', 'error');
            }
        }

        function testZoomIn() {
            if (editor && editor.canvasManager) {
                editor.canvasManager.zoomIn();
                showResult('Zoomed in', 'success');
            } else {
                showResult('Canvas not ready', 'error');
            }
        }

        function testZoomOut() {
            if (editor && editor.canvasManager) {
                editor.canvasManager.zoomOut();
                showResult('Zoomed out', 'success');
            } else {
                showResult('Canvas not ready', 'error');
            }
        }

        function testFitWindow() {
            if (editor && editor.canvasManager) {
                editor.canvasManager.fitToWindow();
                showResult('Fit to window', 'success');
            } else {
                showResult('Canvas not ready', 'error');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (!e.ctrlKey && !e.metaKey && !e.target.matches('input')) {
                switch(e.key.toLowerCase()) {
                    case 'v': selectTool('pointer'); break;
                    case 't': selectTool('text'); break;
                    case 'r': selectTool('rectangle'); break;
                    case 'c': selectTool('circle'); break;
                    case 'l': selectTool('line'); break;
                    case 'a': selectTool('arrow'); break;
                    case 'p': selectTool('pen'); break;
                    case 'h': selectTool('highlight'); break;
                }
            }
        });

        // Load dependencies and initialize
        function loadScript(src, callback) {
            var script = document.createElement('script');
            script.src = src;
            script.onload = callback;
            script.onerror = function() {
                logStep('Failed to load: ' + src);
                callback(new Error('Failed to load ' + src));
            };
            document.head.appendChild(script);
        }

        function loadCSS(href) {
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = href;
            document.head.appendChild(link);
        }

        // Initialize step by step
        async function initialize() {
            try {
                logStep('Starting initialization...');
                
                // Load CSS
                loadCSS('resources/ext.layers.editor/editor.css');
                logStep('CSS loaded');
                
                // Load JavaScript files in order
                await new Promise((resolve, reject) => {
                    loadScript('resources/ext.layers.editor/CanvasManager.js', (err) => {
                        if (err) reject(err);
                        else {
                            logStep('CanvasManager.js loaded');
                            resolve();
                        }
                    });
                });

                await new Promise((resolve, reject) => {
                    loadScript('resources/ext.layers.editor/LayerPanel.js', (err) => {
                        if (err) {
                            logStep('LayerPanel.js failed, continuing...');
                            resolve(); // Continue even if this fails
                        } else {
                            logStep('LayerPanel.js loaded');
                            resolve();
                        }
                    });
                });

                await new Promise((resolve, reject) => {
                    loadScript('resources/ext.layers.editor/Toolbar.js', (err) => {
                        if (err) {
                            logStep('Toolbar.js failed, continuing...');
                            resolve(); // Continue even if this fails
                        } else {
                            logStep('Toolbar.js loaded');
                            resolve();
                        }
                    });
                });

                await new Promise((resolve, reject) => {
                    loadScript('resources/ext.layers.editor/LayersEditor.js', (err) => {
                        if (err) reject(err);
                        else {
                            logStep('LayersEditor.js loaded');
                            resolve();
                        }
                    });
                });

                // Wait a bit for everything to settle
                await new Promise(resolve => setTimeout(resolve, 100));

                // Check what's available
                logStep('Checking dependencies...');
                logStep('CanvasManager available: ' + (typeof window.CanvasManager !== 'undefined'));
                logStep('LayerPanel available: ' + (typeof window.LayerPanel !== 'undefined'));
                logStep('Toolbar available: ' + (typeof window.Toolbar !== 'undefined'));
                logStep('LayersEditor available: ' + (typeof window.LayersEditor !== 'undefined'));

                // Create minimal missing components if needed
                if (typeof window.LayerPanel === 'undefined') {
                    logStep('Creating minimal LayerPanel...');
                    window.LayerPanel = function(config) {
                        this.container = config.container;
                        this.editor = config.editor;
                        this.container.innerHTML = '<h3>Layer Panel</h3><div>Layers will appear here...</div>';
                        this.updateLayers = function(layers) {
                            console.log('LayerPanel: updateLayers called with', layers.length, 'layers');
                        };
                        this.selectLayer = function(layerId) {
                            console.log('LayerPanel: selectLayer called with', layerId);
                        };
                    };
                }

                if (typeof window.Toolbar === 'undefined') {
                    logStep('Creating minimal Toolbar...');
                    window.Toolbar = function(config) {
                        this.container = config.container;
                        this.editor = config.editor;
                        this.container.innerHTML = '<div>üé® Layers Editor Toolbar - Tools available via buttons below</div>';
                        this.updateUndoRedoState = function(canUndo, canRedo) {
                            console.log('Toolbar: undo/redo state updated:', canUndo, canRedo);
                        };
                        this.updateDeleteState = function(canDelete) {
                            console.log('Toolbar: delete state updated:', canDelete);
                        };
                        this.updateZoomDisplay = function(zoomPercent) {
                            console.log('Toolbar: zoom display updated:', zoomPercent + '%');
                        };
                    };
                }

                // Create editor
                logStep('Creating LayersEditor...');
                var editorContainer = document.getElementById('editor-container');
                editorContainer.innerHTML = ''; // Clear loading message

                if (typeof window.LayersEditor !== 'undefined') {
                    editor = new window.LayersEditor({
                        filename: 'test-image.png',
                        container: editorContainer
                    });
                    
                    logStep('LayersEditor created successfully');
                    
                    // Wait for editor to initialize
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    logStep('Editor initialization complete');
                    logStep('Canvas Manager: ' + (editor.canvasManager ? 'OK' : 'FAILED'));
                    logStep('Layer Panel: ' + (editor.layerPanel ? 'OK' : 'FAILED'));
                    logStep('Toolbar: ' + (editor.toolbar ? 'OK' : 'FAILED'));
                    
                    updateToolButtons();
                    updateStyle();
                    
                    document.getElementById('loading-status').innerHTML = 
                        '‚úÖ <strong>Editor Ready!</strong> You can now draw on the canvas above.';
                    
                    showResult('Layers editor loaded successfully!', 'success');
                } else {
                    throw new Error('LayersEditor not available after loading');
                }

            } catch (error) {
                logStep('Initialization failed: ' + error.message);
                document.getElementById('loading-status').innerHTML = 
                    '‚ùå <strong>Failed to load editor:</strong> ' + error.message;
                showResult('Failed to initialize editor: ' + error.message, 'error');
            }
        }

        // Start initialization when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }

    </script>
</body>
</html>
