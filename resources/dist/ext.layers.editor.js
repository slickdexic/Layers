/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/ext.layers.editor/LayersEditor.js":
/*!*****************************************************!*\
  !*** ./resources/ext.layers.editor/LayersEditor.js ***!
  \*****************************************************/
/***/ (() => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/**\n * Main Layers Editor - manages the overall editing interface and coordinates between components\n */\n(function () {\n  'use strict';\n\n  /**\n   * Main Layers Editor class for MediaWiki Layers extension\n   *\n   * @class LayersEditor\n   * @param {Object} config - Configuration object\n   * @param {string} config.filename - Name of the file being edited\n   * @param {string} config.imageUrl - URL of the base image\n   * @param {HTMLElement} config.container - Container element for the editor\n   */\n  function LayersEditor(config) {\n    var _this = this;\n    this.config = config || {};\n    this.filename = this.config.filename;\n    this.containerElement = this.config.container; // Optional legacy container\n    this.canvasManager = null;\n    this.layerPanel = null;\n    this.toolbar = null;\n\n    // Event listener tracking for cleanup\n    this.domEventListeners = [];\n    this.windowListeners = [];\n    this.documentListeners = [];\n    this.isDestroyed = false;\n\n    // Debug mode - check MediaWiki config first, then fallback to config\n    this.debug = mw.config.get('wgLayersDebug') || this.config.debug || false;\n\n    // Debug logging helper\n    this.debugLog = function () {\n      if (this.debug) {\n        console.log.apply(console, arguments);\n      }\n    }.bind(this);\n    this.debugInfo = function () {\n      if (this.debug) {\n        console.info.apply(console, arguments);\n      }\n    }.bind(this);\n    this.debugLog('[LayersEditor] Constructor called with config:', this.config);\n    this.debugLog('[LayersEditor] Constructor config details:', {\n      hasFilename: !!this.filename,\n      hasContainer: !!this.containerElement,\n      filename: this.filename,\n      container: this.containerElement\n    });\n\n    // Set image URL from config\n    this.imageUrl = this.config.imageUrl;\n\n    // Initialize module registry if not available\n    this.registry = window.layersRegistry || window.layersModuleRegistry;\n    if (!this.registry) {\n      // Create a basic fallback registry\n      this.registry = {\n        get: function get(name) {\n          var constructors = {\n            UIManager: function UIManager() {\n              return new window.UIManager(_this);\n            },\n            EventManager: function EventManager() {\n              return new window.EventManager(_this);\n            },\n            APIManager: function APIManager() {\n              return new window.APIManager(_this);\n            },\n            ValidationManager: function ValidationManager() {\n              return new window.ValidationManager(_this);\n            },\n            StateManager: function StateManager() {\n              return new window.StateManager(_this);\n            },\n            HistoryManager: function HistoryManager() {\n              return new window.HistoryManager(_this);\n            }\n          };\n          if (constructors[name]) {\n            return constructors[name]();\n          }\n          throw new Error(\"Module \".concat(name, \" not found\"));\n        }\n      };\n    }\n\n    // Register manager factories with context\n    if (this.registry.register) {\n      this.registry.register('UIManager', function () {\n        return new window.UIManager(_this);\n      }, []);\n      this.registry.register('EventManager', function () {\n        return new window.EventManager(_this);\n      }, []);\n      this.registry.register('APIManager', function () {\n        return new window.APIManager(_this);\n      }, []);\n      this.registry.register('ValidationManager', function () {\n        return new window.ValidationManager(_this);\n      }, []);\n      this.registry.register('StateManager', function () {\n        return new window.StateManager(_this);\n      }, []);\n      this.registry.register('HistoryManager', function () {\n        return new window.HistoryManager(_this);\n      }, []);\n    }\n\n    // Initialize managers through registry\n    this.uiManager = this.registry.get('UIManager');\n    this.eventManager = this.registry.get('EventManager');\n    this.apiManager = this.registry.get('APIManager');\n    this.validationManager = this.registry.get('ValidationManager');\n    this.stateManager = this.registry.get('StateManager');\n\n    // Initialize state through StateManager\n    this.stateManager.set('layers', []);\n    this.stateManager.set('selectedLayerId', null);\n    this.stateManager.set('isDirty', false);\n    this.stateManager.set('currentTool', 'pointer');\n    this.stateManager.set('baseWidth', null);\n    this.stateManager.set('baseHeight', null);\n    this.stateManager.set('allLayerSets', []);\n    this.stateManager.set('currentLayerSetId', null);\n\n    // Initialize HistoryManager for undo/redo\n    this.historyManager = this.registry.get('HistoryManager');\n\n    // BRIDGE: Provide backward-compatible editor.layers property that routes through StateManager\n    // This allows legacy code to work while we complete the migration\n    Object.defineProperty(this, 'layers', {\n      get: function () {\n        return this.stateManager.getLayers();\n      }.bind(this),\n      set: function (layers) {\n        if (Array.isArray(layers)) {\n          this.stateManager.set('layers', layers);\n        }\n      }.bind(this),\n      enumerable: true,\n      configurable: true\n    });\n    this.init();\n  }\n\n  /**\n   * Debug logging utility that only logs when debug mode is enabled\n   * Sanitizes messages to prevent information disclosure\n   *\n   * @param {...*} args Arguments to log\n   */\n  LayersEditor.prototype.debugLog = function () {\n    if (this.debug) {\n      // Sanitize arguments to prevent sensitive data exposure\n      var sanitizedArgs = Array.prototype.slice.call(arguments).map(function (arg) {\n        return LayersEditor.prototype.sanitizeLogMessage(arg);\n      });\n\n      // Using MediaWiki's logging system for consistent debug output\n      if (mw.log) {\n        mw.log.apply(mw, sanitizedArgs);\n      }\n    }\n  };\n\n  /**\n   * Error logging utility with message sanitization\n   * Ensures no sensitive information is exposed in console logs\n   *\n   * @param {...*} args Arguments to log\n   */\n  LayersEditor.prototype.errorLog = function () {\n    // Sanitize error messages before logging\n    var sanitizedArgs = Array.prototype.slice.call(arguments).map(function (arg) {\n      return LayersEditor.prototype.sanitizeLogMessage(arg);\n    });\n\n    // Always log errors using MediaWiki's error handling\n    if (mw.log) {\n      mw.log.error.apply(mw.log, sanitizedArgs);\n    }\n  };\n\n  /**\n   * Sanitize log messages to prevent sensitive information disclosure\n   * Uses a whitelist approach for better security\n   *\n   * @param {*} message The message to sanitize\n   * @return {*} Sanitized message\n   */\n  LayersEditor.prototype.sanitizeLogMessage = function (message) {\n    // Don't modify non-string values\n    if (typeof message !== 'string') {\n      // For objects, use a whitelist approach for safety\n      if (_typeof(message) === 'object' && message !== null) {\n        var safeKeys = ['type', 'action', 'status', 'tool', 'layer', 'count', 'x', 'y', 'width', 'height'];\n        var obj = {};\n        for (var key in message) {\n          if (Object.prototype.hasOwnProperty.call(message, key)) {\n            if (safeKeys.includes(key)) {\n              obj[key] = message[key];\n            } else {\n              obj[key] = '[FILTERED]';\n            }\n          }\n        }\n        return obj;\n      }\n      return message;\n    }\n\n    // For strings, apply comprehensive sanitization\n    var result = String(message);\n\n    // Remove any token-like patterns (base64, hex, etc.)\n    result = result.replace(/[a-zA-Z0-9+/=]{20,}/g, '[TOKEN]');\n    result = result.replace(/[a-fA-F0-9]{16,}/g, '[HEX]');\n\n    // Remove file paths completely\n    result = result.replace(/[A-Za-z]:[\\\\/]][\\w\\s\\\\.-]*/g, '[PATH]');\n    // Remove file paths completely\n    result = result.replace(/\\/[\\w\\s.-]+/g, '[PATH]');\n\n    // Remove URLs and connection strings\n    result = result.replace(/https?:\\/\\/[^\\s'\"<>&]*/gi, '[URL]');\n    result = result.replace(/\\w+:\\/\\/[^\\s'\"<>&]*/gi, '[CONNECTION]');\n\n    // Remove IP addresses and ports\n    result = result.replace(/\\b(?:\\d{1,3}\\.){3}\\d{1,3}(?::\\d+)?\\b/g, '[IP]');\n\n    // Remove email addresses\n    result = result.replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g, '[EMAIL]');\n\n    // Limit length to prevent log flooding\n    if (result.length > 200) {\n      result = result.slice(0, 200) + '[TRUNCATED]';\n    }\n    return result;\n  };\n\n  /**\n   * Render layers on canvas (bridge method)\n   * @param {Array} layers Optional array of layers to render\n   */\n  LayersEditor.prototype.renderLayers = function (layers) {\n    if (this.canvasManager && typeof this.canvasManager.renderLayers === 'function') {\n      this.canvasManager.renderLayers(layers || this.stateManager.getLayers());\n    }\n  };\n\n  /**\n   * Check if editor has unsaved changes\n   * @return {boolean} True if there are unsaved changes\n   */\n  LayersEditor.prototype.isDirty = function () {\n    return this.stateManager.isDirty();\n  };\n\n  /**\n   * Mark editor as having unsaved changes\n   */\n  LayersEditor.prototype.markDirty = function () {\n    this.stateManager.setDirty(true);\n  };\n\n  /**\n   * Mark editor as clean (no unsaved changes)\n   */\n  LayersEditor.prototype.markClean = function () {\n    this.stateManager.setDirty(false);\n  };\n\n  /**\n   * Undo last action\n   * @return {boolean} True if undo was successful\n   */\n  LayersEditor.prototype.undo = function () {\n    if (this.historyManager && typeof this.historyManager.undo === 'function') {\n      return this.historyManager.undo();\n    }\n    return false;\n  };\n\n  /**\n   * Redo last undone action\n   * @return {boolean} True if redo was successful\n   */\n  LayersEditor.prototype.redo = function () {\n    if (this.historyManager && typeof this.historyManager.redo === 'function') {\n      return this.historyManager.redo();\n    }\n    return false;\n  };\n  LayersEditor.prototype.init = function () {\n    var _this2 = this;\n    // Add immediate visual feedback\n    document.title = 'ðŸ”„ Layers Editor Loading...';\n    this.debugLog('[LayersEditor] init() method called');\n    this.debugLog('[LayersEditor] init() - checking browser compatibility');\n\n    // Check browser compatibility first\n    if (!this.validationManager.checkBrowserCompatibility()) {\n      this.uiManager.showBrowserCompatibilityWarning();\n      return;\n    }\n\n    // Create the main editor interface\n    this.uiManager.createInterface();\n    this.debugLog('[LayersEditor] UI Manager created interface');\n    this.debugLog('[LayersEditor] UI Manager containers:', {\n      mainContainer: this.uiManager.container,\n      toolbarContainer: this.uiManager.toolbarContainer,\n      layerPanelContainer: this.uiManager.layerPanelContainer,\n      canvasContainer: this.uiManager.canvasContainer\n    });\n\n    // Register UI component factories with context after UI manager creates containers\n    if (this.registry.register) {\n      this.registry.register('Toolbar', function () {\n        return new window.Toolbar({\n          container: _this2.uiManager.toolbarContainer,\n          editor: _this2\n        });\n      }, []);\n      this.registry.register('LayerPanel', function () {\n        return new window.LayerPanel({\n          container: _this2.uiManager.layerPanelContainer,\n          editor: _this2\n        });\n      }, []);\n      this.registry.register('CanvasManager', function () {\n        return new window.CanvasManager({\n          container: _this2.uiManager.canvasContainer,\n          editor: _this2,\n          backgroundImageUrl: _this2.imageUrl\n        });\n      }, []);\n    }\n\n    // Initialize UI components through registry\n    this.toolbar = this.registry.get('Toolbar');\n    this.debugLog('[LayersEditor] Toolbar created:', this.toolbar);\n    this.layerPanel = this.registry.get('LayerPanel');\n    this.debugLog('[LayersEditor] LayerPanel created:', this.layerPanel);\n    this.canvasManager = this.registry.get('CanvasManager');\n    this.debugLog('[LayersEditor] CanvasManager created:', this.canvasManager);\n    this.debugLog('[LayersEditor] CanvasManager backgroundImageUrl:', this.imageUrl);\n\n    // Initialize undo/redo system\n    this.undoStack = [];\n    this.redoStack = [];\n    this.maxUndoSteps = 50;\n\n    // Load existing layers\n    this.apiManager.loadLayers().then(function (data) {\n      _this2.debugLog('[LayersEditor] API loadLayers completed with data:', data);\n      if (data && data.layers) {\n        // Normalize layers to ensure visibility defaults are correct\n        var normalizedLayers = _this2.normalizeLayers(data.layers);\n        _this2.stateManager.set('layers', normalizedLayers);\n      } else {\n        _this2.stateManager.set('layers', []);\n      }\n      if (data && data.baseWidth) {\n        _this2.stateManager.set('baseWidth', data.baseWidth);\n        // Sync base dimensions to canvas manager\n        if (_this2.canvasManager && _this2.canvasManager.setBaseDimensions) {\n          _this2.canvasManager.setBaseDimensions(data.baseWidth, data.baseHeight);\n        }\n      }\n      if (data && data.baseHeight) {\n        _this2.stateManager.set('baseHeight', data.baseHeight);\n      }\n      if (data && data.allLayerSets) {\n        _this2.stateManager.set('allLayerSets', data.allLayerSets);\n      }\n      if (data && data.currentLayerSetId) {\n        _this2.stateManager.set('currentLayerSetId', data.currentLayerSetId);\n      }\n      var layers = _this2.stateManager.get('layers') || [];\n      _this2.debugLog('[LayersEditor] About to render layers:', layers.length, 'layers');\n      if (_this2.canvasManager) {\n        _this2.canvasManager.renderLayers(layers);\n      }\n      _this2.saveState('initial');\n    })[\"catch\"](function (error) {\n      _this2.debugLog('[LayersEditor] API loadLayers failed:', error);\n      _this2.stateManager.set('layers', []);\n      if (_this2.canvasManager) {\n        _this2.canvasManager.renderLayers([]);\n      }\n      _this2.saveState('initial');\n    });\n\n    // Set up event handlers\n    this.eventManager.setupGlobalHandlers();\n\n    // Set up close button handler\n    this.setupCloseButton();\n    document.title = 'ðŸŽ¨ Layers Editor - ' + (this.filename || 'Unknown File');\n  };\n  LayersEditor.prototype.setupCloseButton = function () {\n    var _this3 = this;\n    var closeBtn = this.uiManager.container.querySelector('.layers-header-close');\n    if (closeBtn) {\n      var closeHandler = function closeHandler() {\n        _this3.cancel(true);\n      };\n      this.trackEventListener(closeBtn, 'click', closeHandler);\n    }\n  };\n\n  /**\n   * Add a new layer to the editor\n   *\n   * @param {Object} layerData - Layer data object\n   * @return {void}\n   */\n  LayersEditor.prototype.addLayer = function (layerData) {\n    // Save current state for undo\n    this.saveState();\n\n    // Sanitize layer data for security\n    layerData = this.validationManager.sanitizeLayerData(layerData);\n\n    // Add new layer\n    layerData.id = this.apiManager.generateLayerId();\n    layerData.visible = layerData.visible !== false; // Default to visible\n\n    // Get current layers from state manager\n    var layers = this.stateManager.get('layers') || [];\n    // Insert at top so top of list = top of draw order\n    layers.unshift(layerData);\n    // Update state\n    this.stateManager.set('layers', layers);\n    if (this.canvasManager) {\n      this.canvasManager.renderLayers(layers);\n    }\n    this.markDirty();\n\n    // Select the newly created layer\n    this.selectLayer(layerData.id);\n  };\n\n  /**\n   * Update an existing layer with new data\n   *\n   * @param {string} layerId - ID of the layer to update\n   * @param {Object} changes - Changes to apply to the layer\n   * @return {void}\n   */\n  LayersEditor.prototype.updateLayer = function (layerId, changes) {\n    try {\n      // Debug: Log updateLayer call (only in debug mode)\n      if (this.debug) {\n        this.debugLog('updateLayer called with layerId:', layerId, 'changes:', changes);\n      }\n\n      // Save current state for undo\n      this.saveState();\n\n      // Sanitize changes for security\n      changes = this.validationManager.sanitizeLayerData(changes);\n\n      // Get current layers from state manager\n      var layers = this.stateManager.get('layers') || [];\n      // Update existing layer\n      var layer = layers.find(function (l) {\n        return l.id === layerId;\n      });\n      if (layer) {\n        Object.assign(layer, changes);\n        // Update state\n        this.stateManager.set('layers', layers);\n\n        // Trigger full redraw to ensure proper rendering with transforms\n        if (this.canvasManager) {\n          this.canvasManager.redraw();\n        }\n        this.markDirty();\n\n        // Debug: Log successful update (only in debug mode)\n        if (this.debug) {\n          this.debugLog('Layer updated successfully:', layerId, 'new layer data:', layer);\n        }\n      } else {\n        // Debug: Log layer not found (only in debug mode)\n        if (this.debug) {\n          this.debugLog('Layer not found for update:', layerId);\n        }\n      }\n    } catch (error) {\n      // Log error but don't re-throw to prevent breaking the UI\n      if (this.debug) {\n        this.errorLog('Error in updateLayer:', error);\n      }\n      if (window.mw && window.mw.notify) {\n        mw.notify('Error updating layer', {\n          type: 'error'\n        });\n      }\n    }\n  };\n  LayersEditor.prototype.removeLayer = function (layerId) {\n    // Save current state for undo\n    this.saveState();\n\n    // Get current layers from state manager\n    var layers = this.stateManager.get('layers') || [];\n    // Remove layer\n    var updatedLayers = layers.filter(function (layer) {\n      return layer.id !== layerId;\n    });\n    // Update state\n    this.stateManager.set('layers', updatedLayers);\n\n    // Trigger full redraw to ensure proper rendering with transforms\n    if (this.canvasManager) {\n      this.canvasManager.redraw();\n    }\n    this.markDirty();\n\n    // Update UI state\n    this.updateUIState();\n  };\n  LayersEditor.prototype.getLayerById = function (layerId) {\n    var layers = this.stateManager.get('layers') || [];\n    return layers.find(function (layer) {\n      return layer.id === layerId;\n    });\n  };\n  LayersEditor.prototype.markDirty = function () {\n    this.stateManager.set('isDirty', true);\n  };\n\n  /**\n   * Build the revision selector dropdown\n   * @return {void}\n   */\n  LayersEditor.prototype.buildRevisionSelector = function () {\n    var _this4 = this;\n    try {\n      if (this.uiManager && this.uiManager.revSelectEl) {\n        var selectEl = this.uiManager.revSelectEl;\n        var allLayerSets = this.stateManager.get('allLayerSets') || [];\n        var currentLayerSetId = this.stateManager.get('currentLayerSetId');\n\n        // Clear existing options\n        selectEl.innerHTML = '';\n\n        // Add default option\n        var defaultOption = document.createElement('option');\n        defaultOption.value = '';\n        defaultOption.textContent = this.getMessage('layers-revision-latest');\n        selectEl.appendChild(defaultOption);\n\n        // Add revision options\n        allLayerSets.forEach(function (layerSet) {\n          var option = document.createElement('option');\n          option.value = layerSet.ls_id || layerSet.id;\n          var timestamp = layerSet.ls_timestamp || layerSet.timestamp;\n          var userName = layerSet.ls_user_name || layerSet.userName || 'Unknown';\n          var name = layerSet.ls_name || layerSet.name || '';\n          var displayText = new Date(timestamp * 1000).toLocaleString();\n          displayText += ' ' + _this4.getMessage('layers-revision-by') + ' ' + userName;\n          if (name) {\n            displayText += ' (' + name + ')';\n          }\n          option.textContent = displayText;\n          option.selected = (layerSet.ls_id || layerSet.id) === currentLayerSetId;\n          selectEl.appendChild(option);\n        });\n\n        // Update load button state\n        this.updateRevisionLoadButton();\n      }\n    } catch (error) {\n      this.errorLog('Error building revision selector:', error);\n    }\n  };\n\n  /**\n   * Update the revision load button state\n   * @return {void}\n   */\n  LayersEditor.prototype.updateRevisionLoadButton = function () {\n    try {\n      if (this.uiManager && this.uiManager.revLoadBtnEl && this.uiManager.revSelectEl) {\n        var selectedValue = this.uiManager.revSelectEl.value;\n        var currentLayerSetId = this.stateManager.get('currentLayerSetId');\n        var isCurrent = selectedValue && parseInt(selectedValue, 10) === currentLayerSetId;\n        this.uiManager.revLoadBtnEl.disabled = !selectedValue || isCurrent;\n      }\n    } catch (error) {\n      this.errorLog('Error updating revision load button:', error);\n    }\n  };\n\n  /**\n   * Load a specific revision by ID\n   * @param {number} revisionId - The revision ID to load\n   * @return {void}\n   */\n  LayersEditor.prototype.loadRevisionById = function (revisionId) {\n    try {\n      this.apiManager.loadRevisionById(revisionId);\n    } catch (error) {\n      this.errorLog('Error loading revision:', error);\n      mw.notify(this.getMessage('layers-revision-load-error'), {\n        type: 'error'\n      });\n    }\n  };\n\n  /**\n   * Get a localized message\n   * @param {string} key - Message key\n   * @param {string} fallback - Fallback text\n   * @return {string} Localized message\n   */\n  LayersEditor.prototype.getMessage = function (key) {\n    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return mw.message ? mw.message(key).text() : mw.msg ? mw.msg(key) : fallback;\n  };\n  LayersEditor.prototype.setCurrentTool = function (tool) {\n    this.stateManager.set('currentTool', tool);\n    if (this.canvasManager) {\n      this.canvasManager.setTool(tool);\n    }\n    if (this.toolbar) {\n      this.toolbar.setActiveTool(tool);\n    }\n  };\n\n  // Undo/Redo System\n  LayersEditor.prototype.saveState = function (action) {\n    // Delegate to canvas manager's history system\n    if (this.historyManager) {\n      this.historyManager.saveState(action);\n    }\n  };\n  LayersEditor.prototype.undo = function () {\n    // Delegate to canvas manager's undo system\n    if (this.historyManager) {\n      return this.historyManager.undo();\n    }\n    return false;\n  };\n  LayersEditor.prototype.redo = function () {\n    // Delegate to canvas manager's redo system\n    if (this.historyManager) {\n      return this.historyManager.redo();\n    }\n    return false;\n  };\n\n  // Selection Management\n  LayersEditor.prototype.selectLayer = function (layerId) {\n    try {\n      this.stateManager.set('selectedLayerId', layerId);\n\n      // Update canvas selection\n      if (this.canvasManager) {\n        this.canvasManager.selectLayer(layerId);\n      }\n\n      // Update layer panel selection\n      if (this.layerPanel) {\n        this.layerPanel.selectLayer(layerId);\n      }\n\n      // Update UI state (toolbar buttons, etc.)\n      this.updateUIState();\n\n      // this.debugLog( 'Selected layer:', layerId );\n    } catch (error) {\n      // Log error but don't re-throw to prevent breaking the UI\n      if (this.debug) {\n        this.errorLog('Error in selectLayer:', error);\n      }\n      if (window.mw && window.mw.notify) {\n        mw.notify('Error selecting layer', {\n          type: 'error'\n        });\n      }\n    }\n  };\n  LayersEditor.prototype.deleteSelected = function () {\n    var selectedLayerId = this.stateManager.get('selectedLayerId');\n    if (selectedLayerId) {\n      this.removeLayer(selectedLayerId);\n      this.stateManager.set('selectedLayerId', null);\n    }\n  };\n  LayersEditor.prototype.duplicateSelected = function () {\n    var selectedLayerId = this.stateManager.get('selectedLayerId');\n    if (selectedLayerId) {\n      var layer = this.getLayerById(selectedLayerId);\n      if (layer) {\n        var duplicate = JSON.parse(JSON.stringify(layer));\n        duplicate.x = (duplicate.x || 0) + 10;\n        duplicate.y = (duplicate.y || 0) + 10;\n        delete duplicate.id; // Will be regenerated\n        this.addLayer(duplicate);\n      }\n    }\n  };\n  LayersEditor.prototype.updateUIState = function () {\n    try {\n      // Update toolbar state\n      if (this.toolbar) {\n        var canUndo = this.historyManager ? this.historyManager.canUndo() : false;\n        var canRedo = this.historyManager ? this.historyManager.canRedo() : false;\n        var selectedLayerId = this.stateManager.get('selectedLayerId');\n        this.toolbar.updateUndoRedoState(canUndo, canRedo);\n        this.toolbar.updateDeleteState(!!selectedLayerId);\n      }\n    } catch (error) {\n      // Log error but don't re-throw to prevent breaking the UI\n      if (this.debug) {\n        this.errorLog('Error in updateUIState:', error);\n      }\n      if (window.mw && window.mw.notify) {\n        mw.notify('Error updating UI state', {\n          type: 'error'\n        });\n      }\n    }\n  };\n\n  // Apply a mutator function to all selected layers; saves state and marks dirty\n  LayersEditor.prototype.applyToSelection = function (mutator) {\n    if (typeof mutator !== 'function') {\n      return;\n    }\n    var ids = this.getSelectedLayerIds();\n    if (!ids.length) {\n      return;\n    }\n    this.saveState();\n    var layers = this.stateManager.get('layers') || [];\n    var _loop = function _loop(i) {\n      var layer = layers.find(function (l) {\n        return l.id === ids[i];\n      });\n      if (layer) {\n        mutator(layer);\n      }\n    };\n    for (var i = 0; i < ids.length; i++) {\n      _loop(i);\n    }\n    this.stateManager.set('layers', layers);\n    if (this.canvasManager) {\n      this.canvasManager.renderLayers(layers);\n    }\n    this.markDirty();\n  };\n\n  // Return selected layer ids from CanvasManager or fallback to single selection\n  LayersEditor.prototype.getSelectedLayerIds = function () {\n    if (this.canvasManager && Array.isArray(this.canvasManager.selectedLayerIds)) {\n      return this.canvasManager.selectedLayerIds.slice();\n    }\n    var selectedLayerId = this.stateManager.get('selectedLayerId');\n    return selectedLayerId ? [selectedLayerId] : [];\n  };\n  LayersEditor.prototype.navigateBackToFile = function () {\n    try {\n      if (this.filename && mw && mw.util && typeof mw.util.getUrl === 'function') {\n        var url = mw.util.getUrl('File:' + this.filename);\n        window.location.href = url;\n        return;\n      }\n      // Fallbacks\n      if (window.history && window.history.length > 1) {\n        window.history.back();\n      } else {\n        window.location.reload();\n      }\n    } catch (e) {\n      // As a last resort, reload\n      window.location.reload();\n    }\n  };\n\n  /**\n   * Save the current layers to the server\n   *\n   * @param {string} [setName] - Optional name for the layer set\n   * @return {void}\n   */\n  LayersEditor.prototype.save = function (setName) {\n    var _this5 = this;\n    // Get layers from state manager\n    var layers = this.stateManager.get('layers') || [];\n\n    // Validate layers before saving using validation manager\n    if (!this.validationManager.validateLayers(layers)) {\n      mw.notify(mw.message ? mw.message('layers-save-validation-error').text() : 'Layer validation failed', {\n        type: 'error'\n      });\n      return;\n    }\n\n    // Show saving spinner using UI manager\n    this.uiManager.showSpinner(mw.message ? mw.message('layers-saving').text() : 'Saving...');\n\n    // Use API manager to save\n    this.apiManager.saveLayers(layers, this.filename, setName).then(function (result) {\n      _this5.uiManager.hideSpinner();\n      _this5.stateManager.set('currentLayerSetId', result.layersetid);\n      _this5.stateManager.markClean();\n      _this5.reloadRevisions();\n      mw.notify(mw.message ? mw.message('layers-save-success').text() : 'Layers saved successfully', {\n        type: 'success'\n      });\n    })[\"catch\"](function (error) {\n      _this5.uiManager.hideSpinner();\n      var errorMsg = error.info || (mw.message ? mw.message('layers-save-error').text() : 'Failed to save layers');\n      mw.notify(errorMsg, {\n        type: 'error'\n      });\n    });\n  };\n\n  /**\n   * Reload the revision selector after saving\n   * @return {void}\n   */\n  LayersEditor.prototype.reloadRevisions = function () {\n    var _this6 = this;\n    try {\n      // Reload layers data to get updated revision list\n      this.apiManager.loadLayers().then(function (data) {\n        if (data && data.allLayerSets) {\n          _this6.stateManager.set('allLayerSets', data.allLayerSets);\n        }\n        // Rebuild the revision selector\n        _this6.buildRevisionSelector();\n      })[\"catch\"](function (error) {\n        _this6.errorLog('Error reloading revisions:', error);\n      });\n    } catch (error) {\n      this.errorLog('Error in reloadRevisions:', error);\n    }\n  };\n  // Accessibility: Add ARIA roles and keyboard navigation stubs\n  // TODO: Implement more comprehensive keyboard navigation and screen reader support\n  // Recommendations:\n  // - Add ARIA labels to all toolbar buttons and controls\n  // - Implement Tab navigation through layers panel\n  // - Add keyboard shortcuts help dialog (Shift+? or F1)\n  // - Announce layer selection changes to screen readers\n  // - Add focus indicators for keyboard navigation\n  // - Support arrow key navigation in layer panel\n\n  // Security: Input sanitization before rendering user content\n  // TODO: Ensure all user-generated content is sanitized before rendering in the DOM or canvas\n  // Recommendations:\n  // - Sanitize layer names for XSS prevention\n  // - Validate color values before applying\n  // - Escape text content in text layers\n  // - Validate file paths and URLs\n  // - Use DOMPurify or similar for HTML content\n\n  /**\n   * Normalize layer visibility on load (ensure undefined = visible)\n   * @param {Array} layers - Array of layer objects\n   * @return {Array} Normalized layers\n   */\n  LayersEditor.prototype.normalizeLayers = function (layers) {\n    if (!layers || !Array.isArray(layers)) {\n      return layers;\n    }\n    return layers.map(function (layer) {\n      // Normalize visibility: undefined or true = visible\n      if (layer.visible === undefined) {\n        layer.visible = true;\n      }\n      return layer;\n    });\n  };\n\n  /**\n   * Cancel editing and return to the file page\n   *\n   * @param {boolean} navigateBack - Whether to navigate back to the file page\n   * @return {void}\n   */\n  LayersEditor.prototype.cancel = function (navigateBack) {\n    // Check for unsaved changes\n    var isDirty = this.stateManager.get('isDirty');\n    if (isDirty) {\n      var confirmMsg = mw.message ? mw.message('layers-cancel-confirm').text() : 'You have unsaved changes. Are you sure you want to close?';\n      // eslint-disable-next-line no-alert\n      if (!window.confirm(confirmMsg)) {\n        return;\n      }\n    }\n\n    // Use UI manager to handle close\n    this.uiManager.destroy();\n    if (navigateBack) {\n      this.navigateBackToFile();\n    }\n  };\n\n  /**\n   * Handle keyboard shortcuts and navigation\n   *\n   * @param {KeyboardEvent} e - Keyboard event\n   * @private\n   */\n  LayersEditor.prototype.handleKeyDown = function (e) {\n    this.eventManager.handleKeyDown(e);\n  };\n  LayersEditor.prototype.destroy = function () {\n    // Prevent multiple destroy calls\n    if (this.isDestroyed) {\n      return;\n    }\n    this.isDestroyed = true;\n\n    // Clean up global event listeners if this instance registered them\n    this.cleanupGlobalEventListeners();\n\n    // Clean up managers\n    if (this.uiManager && typeof this.uiManager.destroy === 'function') {\n      this.uiManager.destroy();\n    }\n    if (this.eventManager && typeof this.eventManager.destroy === 'function') {\n      this.eventManager.destroy();\n    }\n    if (this.apiManager && typeof this.apiManager.destroy === 'function') {\n      this.apiManager.destroy();\n    }\n    if (this.validationManager && typeof this.validationManager.destroy === 'function') {\n      this.validationManager.destroy();\n    }\n    if (this.stateManager && typeof this.stateManager.destroy === 'function') {\n      this.stateManager.destroy();\n    }\n    if (this.historyManager) {\n      if (typeof this.historyManager.destroy === 'function') {\n        this.historyManager.destroy();\n      } else if (typeof this.historyManager.clearHistory === 'function') {\n        this.historyManager.clearHistory();\n      }\n    }\n\n    // Clean up canvas manager and its event systems\n    if (this.canvasManager) {\n      if (this.canvasManager.eventSystem && typeof this.canvasManager.eventSystem.destroy === 'function') {\n        this.canvasManager.eventSystem.destroy();\n      }\n      if (this.canvasManager.selectionSystem && typeof this.canvasManager.selectionSystem.destroy === 'function') {\n        this.canvasManager.selectionSystem.destroy();\n      }\n      if (typeof this.canvasManager.destroy === 'function') {\n        this.canvasManager.destroy();\n      }\n    }\n\n    // Clean up toolbar and layer panel\n    if (this.toolbar && typeof this.toolbar.destroy === 'function') {\n      this.toolbar.destroy();\n    }\n    if (this.layerPanel && typeof this.layerPanel.destroy === 'function') {\n      this.layerPanel.destroy();\n    }\n\n    // Clean up DOM elements and their event listeners\n    this.cleanupDOMEventListeners();\n\n    // Clear all object references to prevent memory leaks\n    this.uiManager = null;\n    this.eventManager = null;\n    this.apiManager = null;\n    this.validationManager = null;\n    this.stateManager = null;\n    this.historyManager = null;\n    this.canvasManager = null;\n    this.toolbar = null;\n    this.layerPanel = null;\n    this.config = null;\n    this.filename = null;\n    this.containerElement = null;\n    this.imageUrl = null;\n\n    // Clear any cached references\n    this.layers = null;\n    this.clipboard = null;\n    this.undoStack = null;\n    this.redoStack = null;\n  };\n\n  /**\n   * Clean up global event listeners to prevent memory leaks\n   */\n  LayersEditor.prototype.cleanupGlobalEventListeners = function () {\n    // Note: Global error handlers are shared and shouldn't be removed per instance\n    // Only clean up instance-specific listeners\n\n    // Remove any window listeners that were added for this specific instance\n    if (this.windowListeners) {\n      this.windowListeners.forEach(function (listenerInfo) {\n        window.removeEventListener(listenerInfo.event, listenerInfo.handler);\n      });\n      this.windowListeners = [];\n    }\n\n    // Remove any document listeners that were added for this specific instance\n    if (this.documentListeners) {\n      this.documentListeners.forEach(function (listenerInfo) {\n        document.removeEventListener(listenerInfo.event, listenerInfo.handler);\n      });\n      this.documentListeners = [];\n    }\n  };\n\n  /**\n   * Clean up DOM event listeners to prevent memory leaks\n   */\n  LayersEditor.prototype.cleanupDOMEventListeners = function () {\n    // Clean up container element listeners\n    if (this.containerElement) {\n      // Remove all event listeners from container by cloning it\n      var newContainer = this.containerElement.cloneNode(true);\n      if (this.containerElement.parentNode) {\n        this.containerElement.parentNode.replaceChild(newContainer, this.containerElement);\n      }\n    }\n\n    // Clean up any other DOM elements with listeners\n    if (this.domEventListeners) {\n      this.domEventListeners.forEach(function (listenerInfo) {\n        if (listenerInfo.element && listenerInfo.element.removeEventListener) {\n          listenerInfo.element.removeEventListener(listenerInfo.event, listenerInfo.handler);\n        }\n      });\n      this.domEventListeners = [];\n    }\n  };\n\n  /**\n   * Track event listeners for proper cleanup\n   * @param {Element} element DOM element\n   * @param {string} event Event name\n   * @param {Function} handler Event handler\n   */\n  LayersEditor.prototype.trackEventListener = function (element, event, handler) {\n    if (!this.domEventListeners) {\n      this.domEventListeners = [];\n    }\n    this.domEventListeners.push({\n      element: element,\n      event: event,\n      handler: handler\n    });\n    element.addEventListener(event, handler);\n  };\n\n  /**\n   * Track window event listeners for proper cleanup\n   * @param {string} event Event name\n   * @param {Function} handler Event handler\n   */\n  LayersEditor.prototype.trackWindowListener = function (event, handler) {\n    if (!this.windowListeners) {\n      this.windowListeners = [];\n    }\n    this.windowListeners.push({\n      event: event,\n      handler: handler\n    });\n    window.addEventListener(event, handler);\n  };\n\n  // Export LayersEditor to global scope\n  window.LayersEditor = LayersEditor;\n\n  /**\n   * Global error message sanitizer for preventing information disclosure\n   * @param {Error|string|*} error Error object or message to sanitize\n   * @return {string} Sanitized error message\n   */\n  function sanitizeGlobalErrorMessage(error) {\n    var message = 'An error occurred';\n    try {\n      if (error && typeof error.message === 'string') {\n        message = error.message;\n      } else if (typeof error === 'string') {\n        message = error;\n      } else if (error && error.toString) {\n        message = error.toString();\n      }\n\n      // Apply the same sanitization logic as in LayersEditor\n      if (typeof message !== 'string') {\n        return 'Non-string error encountered';\n      }\n\n      // Remove any token-like patterns (base64, hex, etc.)\n      message = message.replace(/[a-zA-Z0-9+/=]{20,}/g, '[TOKEN]');\n      message = message.replace(/[a-fA-F0-9]{16,}/g, '[HEX]');\n\n      // Remove file paths completely\n      message = message.replace(/[A-Za-z]:[\\\\/][\\w\\s\\\\.-]*/g, '[PATH]');\n      message = message.replace(/\\/[\\w\\s.-]+/g, '[PATH]');\n\n      // Remove URLs and connection strings\n      message = message.replace(/https?:\\/\\/[^\\s'\"<>&]*/gi, '[URL]');\n      message = message.replace(/\\w+:\\/\\/[^\\s'\"<>&]*/gi, '[CONNECTION]');\n\n      // Remove IP addresses and ports\n      message = message.replace(/\\b(?:\\d{1,3}\\.){3}\\d{1,3}(?::\\d+)?\\b/g, '[IP]');\n\n      // Remove email addresses\n      message = message.replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g, '[EMAIL]');\n\n      // Limit length to prevent log flooding\n      if (message.length > 200) {\n        message = message.slice(0, 200) + '[TRUNCATED]';\n      }\n      return message;\n    } catch (sanitizeError) {\n      return 'Error sanitization failed';\n    }\n  }\n\n  // Initialize editor when appropriate - ensure mw.hook is available\n  if (typeof mw !== 'undefined' && mw.hook) {\n    if (mw && mw.log) {\n      mw.log('[LayersEditor] About to register hook listener');\n    }\n    var hookListener = function hookListener(config) {\n      if (mw.config.get('wgLayersDebug')) {\n        // Sanitize debug information to prevent information disclosure\n        var sanitizedConfig = {\n          hasFilename: !!(config && config.filename),\n          hasImageUrl: !!(config && config.imageUrl),\n          hasContainer: !!(config && config.container),\n          filename: config && config.filename ? '[FILENAME]' : null,\n          imageUrl: config && config.imageUrl ? '[URL]' : null,\n          container: config && config.container ? '[ELEMENT]' : null\n        };\n        console.log('[LayersEditor] Hook listener called with config (sanitized):', sanitizedConfig);\n      }\n      document.title = 'ðŸŽ¨ Layers Editor Initializing...';\n      try {\n        if (mw.config.get('wgLayersDebug')) {\n          console.log('[LayersEditor] Hook listener: About to create LayersEditor instance');\n        }\n        var editor = new LayersEditor(config);\n        if (mw.config.get('wgLayersDebug')) {\n          console.log('[LayersEditor] LayersEditor instance created successfully');\n        }\n        document.title = 'ðŸŽ¨ Layers Editor - ' + (config.filename || 'Unknown File');\n        // Always set the global instance for duplicate prevention\n        window.layersEditorInstance = editor;\n        if (window.mw && window.mw.config.get('debug')) {\n          window.layersEditorInstance = editor;\n        }\n        if (mw.config.get('wgLayersDebug')) {\n          console.log('[LayersEditor] Hook listener: Editor creation completed successfully');\n        }\n      } catch (e) {\n        // Sanitize error message to prevent information disclosure\n        var sanitizedError = sanitizeGlobalErrorMessage(e);\n        console.error('[LayersEditor] Error creating LayersEditor:', sanitizedError);\n        throw e;\n      }\n    };\n    if (mw.config.get('wgLayersDebug')) {\n      console.log('[LayersEditor] Calling mw.hook(\"layers.editor.init\").add()');\n    }\n    mw.hook('layers.editor.init').add(hookListener);\n    if (mw.config.get('wgLayersDebug')) {\n      console.log('[LayersEditor] Hook listener registered successfully');\n    }\n  } else {\n    // Fallback: try to add hook listener when mw becomes available\n    var _addHookListener = function addHookListener() {\n      if (typeof mw !== 'undefined' && mw.hook) {\n        if (mw.config.get('wgLayersDebug')) {\n          console.log('[LayersEditor] Fallback: mw.hook is now available, registering hook listener');\n        }\n        // ... existing fallback code ...\n      } else {\n        // Retry after a short delay\n        if (mw.config.get('wgLayersDebug')) {\n          console.log('[LayersEditor] Fallback: mw.hook not available yet, retrying in 50ms');\n        }\n        setTimeout(_addHookListener, 50);\n      }\n    };\n    if (mw.config.get('wgLayersDebug')) {\n      console.log('[LayersEditor] Initial mw.hook check:', typeof mw !== 'undefined' && mw.hook);\n    }\n    _addHookListener();\n  }\n\n  // Global error handler for unhandled promise rejections\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('unhandledrejection', function (event) {\n      var error = event.reason;\n      if (error && typeof error.message === 'string' && error.message.includes('message channel closed')) {\n        // This is likely a browser extension or third-party script issue\n        if (mw && mw.log) {\n          mw.log.warn('[Layers] Suppressed message channel error (likely browser extension):', error);\n        }\n        // Prevent the error from being logged to console\n        event.preventDefault();\n      } else if (mw && mw.log) {\n        mw.log.error('[Layers] Unhandled promise rejection:', error);\n      }\n    });\n\n    // Also catch regular errors\n    window.addEventListener('error', function (event) {\n      if (event.error && typeof event.error.message === 'string' && event.error.message.includes('message channel closed')) {\n        if (mw && mw.log) {\n          mw.log.warn('[Layers] Suppressed message channel error (likely browser extension):', event.error);\n        }\n        event.preventDefault();\n      }\n    });\n  }\n\n  // Auto-bootstrap if server provided config via wgLayersEditorInit\n  (function autoBootstrap() {\n    function tryBootstrap() {\n      try {\n        var debug = window.mw && mw.config && mw.config.get('wgLayersDebug');\n        // Always log for now to debug the issue\n        if (debug) {\n          console.log('LayersEditor: Auto-bootstrap starting...');\n          console.log('LayersEditor: Current URL:', window.location.href);\n          console.log('LayersEditor: wgLayersDebug config:', debug);\n        }\n\n        // Ensure MediaWiki is available\n        // Check if MediaWiki is available\n        if (!window.mw || !mw.config || !mw.config.get) {\n          if (debug) {\n            console.log('LayersEditor: MediaWiki not ready, retrying in 100ms...');\n          }\n          setTimeout(tryBootstrap, 100);\n          return;\n        }\n\n        // Try to get config from MediaWiki config vars\n        var init = mw.config.get('wgLayersEditorInit');\n        if (debug) {\n          console.log('LayersEditor: wgLayersEditorInit config:', init);\n        }\n        if (!init) {\n          if (debug) {\n            console.log('LayersEditor: No wgLayersEditorInit config found, not auto-bootstrapping');\n          }\n          return;\n        }\n        if (debug) {\n          console.log('LayersEditor: wgLayersEditorInit config details:', {\n            hasFilename: !!(init && init.filename),\n            hasImageUrl: !!(init && init.imageUrl),\n            filename: init && init.filename,\n            imageUrl: init && init.imageUrl\n          });\n        }\n        var container = document.getElementById('layers-editor-container');\n        if (debug) {\n          console.log('LayersEditor: Container element:', container);\n          console.log('LayersEditor: Container element exists:', !!container);\n          if (container) {\n            console.log('LayersEditor: Container element in document:', document.body.contains(container));\n            console.log('LayersEditor: Container element HTML:', container.outerHTML);\n            console.log('LayersEditor: Container element position in DOM:', container.getBoundingClientRect());\n          } else {\n            console.log('LayersEditor: Container element not found, checking all elements with similar IDs');\n            var allDivs = document.querySelectorAll('div[id*=\"layer\"]');\n            console.log('LayersEditor: Found divs with \"layer\" in ID:', Array.from(allDivs).map(function (el) {\n              return el.id;\n            }));\n          }\n        }\n\n        // Try to fire the hook first (for backward compatibility)\n        if (debug) {\n          console.log('LayersEditor: About to check hook system state');\n\n          // Check if hook system is available and has our hook registered\n          if (typeof mw !== 'undefined' && mw.hook && mw.hook('layers.editor.init')) {\n            var hookObj = mw.hook('layers.editor.init');\n            console.log('LayersEditor: Hook object exists:', !!hookObj);\n            console.log('LayersEditor: Hook has fire method:', typeof hookObj.fire === 'function');\n          }\n        }\n        mw.hook('layers.editor.init').fire({\n          filename: init.filename,\n          imageUrl: init.imageUrl,\n          container: container || document.body\n        });\n        if (debug) {\n          console.log('LayersEditor: Hook fired successfully with config:', {\n            filename: init.filename,\n            imageUrl: init.imageUrl,\n            container: container ? 'layers-editor-container' : 'document.body'\n          });\n          // Check if hook has listeners after firing\n          var hookObjAfter = mw.hook('layers.editor.init');\n          if (hookObjAfter && typeof hookObjAfter.getListeners === 'function') {\n            var listeners = hookObjAfter.getListeners();\n            console.log('LayersEditor: Hook listeners after firing:', listeners ? listeners.length : 'unknown');\n          }\n        }\n        try {\n          // Check if editor already exists (created by hook listener)\n          if (window.layersEditorInstance) {\n            if (debug) {\n              console.log('LayersEditor: Editor already exists from hook listener, skipping direct creation');\n            }\n            return;\n          }\n          if (debug) {\n            console.log('LayersEditor: Attempting direct editor creation with config:', {\n              filename: init.filename,\n              imageUrl: init.imageUrl,\n              container: container ? 'layers-editor-container' : 'document.body'\n            });\n          }\n          var editor = new LayersEditor({\n            filename: init.filename,\n            imageUrl: init.imageUrl,\n            container: container || document.body\n          });\n          if (debug) {\n            console.log('LayersEditor: Direct editor creation successful:', editor);\n          }\n          document.title = 'ðŸŽ¨ Layers Editor - ' + (init.filename || 'Unknown File');\n          if (window.mw && window.mw.config.get('debug')) {\n            window.layersEditorInstance = editor;\n          }\n        } catch (directError) {\n          console.error('LayersEditor: Direct editor creation failed:', sanitizeGlobalErrorMessage(directError));\n          // If direct creation fails, the hook-based approach should still work\n        }\n        if (debug) {\n          console.log('LayersEditor: Auto-bootstrap fired layers.editor.init hook');\n        }\n      } catch (e) {\n        console.error('LayersEditor: Auto-bootstrap error:', sanitizeGlobalErrorMessage(e));\n      }\n    }\n\n    // Try bootstrapping immediately, or when DOM is ready\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', tryBootstrap);\n    } else {\n      tryBootstrap();\n    }\n  })();\n\n  // Add cleanup for page navigation to prevent memory leaks\n  function cleanupGlobalEditorInstance() {\n    if (window.layersEditorInstance && typeof window.layersEditorInstance.destroy === 'function') {\n      window.layersEditorInstance.destroy();\n      window.layersEditorInstance = null;\n    }\n  }\n\n  // Clean up on page unload\n  if (typeof window !== 'undefined') {\n    window.addEventListener('beforeunload', cleanupGlobalEditorInstance);\n\n    // MediaWiki page navigation cleanup\n    if (typeof mw !== 'undefined' && mw.hook) {\n      // Clean up when navigating to new content\n      mw.hook('wikipage.content').add(function () {\n        // Only cleanup if we're not on a layers editor page\n        var isEditLayersPage = mw.config.get('wgAction') === 'editlayers';\n        if (!isEditLayersPage) {\n          cleanupGlobalEditorInstance();\n        }\n      });\n    }\n  }\n})();\n\n//# sourceURL=webpack://Layers/./resources/ext.layers.editor/LayersEditor.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./resources/ext.layers.editor/LayersEditor.js"]();
/******/ 	window["Layersext.layers.editor"] = __webpack_exports__;
/******/ 	
/******/ })()
;