/**
 * Canvas Manager for Layers Editor (Refactored Modular Version)
 * Integrates extracted modules: RenderingCore, LayerRenderer, TransformationEngine,
 * EventSystem, SelectionSystem. Maintains API compatibility while providing modular architecture
 */
( function () {
	'use strict';

	/**
	 * Canvas Manager - Orchestrates modular canvas operations
	 *
	 * @param {Object} config - Configuration object
	 * @class
	 */
	function CanvasManager( config ) {
		// Back-compat: allow new CanvasManager(editorLike)
		if (
			config && !config.container &&
			( config.canvas || config.layers || config.getLayerById )
		) {
			config = {
				editor: config,
				container: ( config.container || null ),
				canvas: config.canvas
			};
		}

		// eslint-disable-next-line no-console
		this.debug = mw.config.get( 'wgLayersDebug' ) || false;
		
		// Debug logging helper
		this.debugInfo = function() {
			if ( this.debug ) {
				console.info.apply( console, arguments );
			}
		}.bind( this );

		this.debugInfo( '[CanvasManager] Constructor called with config:', config );

		this.config = config || {};
		this.container = this.config.container;
		this.editor = this.config.editor;
		this.canvas = null;
		this.ctx = null;
		this.backgroundImage = null;
		this.currentTool = 'pointer';

		// Store the rendered position and size of the background image
		this.backgroundImageRect = { x: 0, y: 0, width: 0, height: 0 };

		// Base dimensions for coordinate scaling
		this.baseWidth = null;
		this.baseHeight = null;

		// Performance optimization properties
		this.dirtyRegion = null;
		this.animationFrameId = null;
		this.redrawScheduled = false;
		this.layersCache = Object.create( null );

		// Throttle transform event emission for live UI sync
		this.transformEventScheduled = false;
		this.lastTransformPayload = null;

		// Drag visual feedback
		this.dragPreview = false;
		this.dragOffset = { x: 0, y: 0 };
		this.showDragGhost = true;

		// Grid and ruler settings
		this.showGrid = false;
		this.showRulers = false;
		this.gridSize = 20;
		this.rulerSize = 30;
		this.gridColor = '#e0e0e0';
		this.rulerColor = '#f5f5f5';
		this.rulerTextColor = '#666666';

		// Guides for snapping
		this.horizontalGuides = [];
		this.verticalGuides = [];
		this.showGuides = true;
		this.snapToGrid = false;
		this.snapToGuides = true;
		this.guideSnapDistance = 10;
		this.isDraggingGuide = false;
		this.dragGuideOrientation = null;
		this.dragGuidePos = 0;

		// Canvas pooling for temporary canvas operations
		this.tempCanvasPool = [];
		this.maxPoolSize = 5;

		// Module instances
		this.renderingCore = null;
		this.layerRenderer = null;
		this.transformationEngine = null;
		this.eventSystem = null;
		this.selectionSystem = null;

		// Initialization tracking
		this.isInitialized = false;
		this.initializationError = null;
		this.isDisposed = false;

		// History system
		this.history = [];
		this.historyIndex = -1;
		this.maxHistorySteps = 50;

		this.init();
	}

	/**
	 * Update style options for the current tool
	 * @param {Object} options Style options to apply
	 */
	CanvasManager.prototype.updateStyleOptions = function ( options ) {
		if ( !options ) {
			return;
		}

		if ( this.toolManager && this.toolManager.currentStyle ) {
			Object.assign( this.toolManager.currentStyle, options );
		}
	};

	/**
	 * Initialize the canvas manager and all modules
	 */
	CanvasManager.prototype.init = function () {
		try {
			this.debugInfo( '[CanvasManager] init() called' );
			this.debugInfo( '[CanvasManager] init() - container:', this.container );
			this.debugInfo( '[CanvasManager] init() - editor:', this.editor );
			this.debugInfo( '[CanvasManager] init() - config:', this.config );

			// Validate required dependencies
			if ( !this.validateDependencies() ) {
				throw new Error( 'Required dependencies not available' );
			}

			// Initialize canvas with proper error handling
			this.initCanvas();

			// Initialize all modules with error handling
			this.initModules();

			// Set up event handlers through EventSystem
			this.setupEventHandlers();

			// Initialize legacy properties for backward compatibility
			this.initLegacyProperties();

			// Load background image if available
			this.loadBackgroundImageSafely();

			// Mark as successfully initialized
			this.isInitialized = true;

			this.debugInfo( '[CanvasManager] Initialization completed successfully' );
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Initialization failed:', error );
			this.handleInitializationError( error );
			throw error;
		}
	};

	/**
	 * Validate required dependencies before initialization
	 * @return {boolean} True if all dependencies are available
	 */
	CanvasManager.prototype.validateDependencies = function () {
		const requiredGlobals = [ 'mw', 'document', 'window' ];
		for ( const global of requiredGlobals ) {
			if ( typeof window[ global ] === 'undefined' ) {
				this.debugInfo( '[CanvasManager] Missing required global:', global );
				return false;
			}
		}

		// Check for container or canvas
		if ( !this.container && !this.config.canvas ) {
			this.debugInfo( '[CanvasManager] No container or canvas provided' );
			return false;
		}

		return true;
	};

	/**
	 * Handle initialization errors gracefully
	 * @param {Error} error The initialization error
	 */
	CanvasManager.prototype.handleInitializationError = function ( error ) {
		this.debugInfo( '[CanvasManager] Handling initialization error:', error.message );
		
		// Set error state
		this.initializationError = error;
		this.isInitialized = false;

		// Emit error event if possible
		if ( this.editor && typeof this.editor.emit === 'function' ) {
			this.editor.emit( 'canvasInitializationError', error );
		}

		// Fallback: show user-friendly error message
		if ( this.container ) {
			this.showErrorMessage( 'Canvas initialization failed. Please refresh the page and try again.' );
		}
	};

	/**
	 * Show error message in the container
	 * @param {string} message Error message to display
	 */
	CanvasManager.prototype.showErrorMessage = function ( message ) {
		if ( !this.container ) {
			return;
		}

		const errorDiv = document.createElement( 'div' );
		errorDiv.className = 'layers-error';
		errorDiv.style.cssText = 'padding: 20px; background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 4px; margin: 10px; text-align: center;';
		errorDiv.textContent = message;
		
		// Clear container and show error
		this.container.innerHTML = '';
		this.container.appendChild( errorDiv );
	};

	/**
	 * Safely load background image with error handling
	 */
	CanvasManager.prototype.loadBackgroundImageSafely = function () {
		try {
			if ( ( this.editor && this.editor.filename ) || this.config.backgroundImageUrl ) {
				this.debugInfo( '[CanvasManager] Loading background image, filename:', this.editor ? this.editor.filename : 'N/A', 'config URL:', this.config.backgroundImageUrl );
				this.loadBackgroundImage( this.config.backgroundImageUrl );
			} else {
				this.debugInfo( '[CanvasManager] No background image to load' );
				// Set flag that we're ready even without background image
				this.isInitialized = true;
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Background image loading failed:', error );
			// Don't fail initialization just because background image failed
			this.isInitialized = true;
		}
	};

	/**
	 * Initialize legacy properties for backward compatibility with tests
	 */
	CanvasManager.prototype.initLegacyProperties = function () {
		// Initialize properties that tests expect to be directly accessible
		this.panX = 0;
		this.panY = 0;
		this.zoom = 1;
		this.userHasSetZoom = false;
		this.spacePressed = false;
		this.clipboard = [];
		this.selectionHandles = [];
		this.rotationHandle = null;

		// Selection system properties
		this.selectedLayerIds = [];
		this.selectedLayerId = null;

		// Resize operation state
		this.isResizing = false;
		this.resizeHandle = null;
		this.resizeStartPoint = null;
		this.resizeStateSaved = false;
		this.originalLayer = null;

		// Drag operation state
		this.isDraggingLayer = false;
		this.dragStartPoint = null;
		this.dragStateSaved = false;
		this.dragOriginalBounds = null;

		// Pan operation state
		this.isPanning = false;
		this.panStartPoint = null;

		// Dirty region tracking for performance optimization
		this.dirtyRegions = [];
		this.backgroundImageChanged = false;
		this.canvasSizeChanged = false;
		this.transformChanged = false;
		this.gridChanged = false;
		this.rulersChanged = false;
		this.guidesChanged = false;
	};

	/**
	 * Initialize canvas element
	 */
	CanvasManager.prototype.initCanvas = function () {
		try {
			// Try to get canvas from config first
			if ( this.config.canvas ) {
				this.canvas = this.config.canvas;
				this.debugInfo( '[CanvasManager] Using canvas from config' );
			} else if ( this.container ) {
				// Look for existing canvas in container
				this.canvas = this.container.querySelector( 'canvas' );
				if ( !this.canvas ) {
					// Create new canvas
					this.canvas = document.createElement( 'canvas' );
					this.container.appendChild( this.canvas );
					this.debugInfo( '[CanvasManager] Created new canvas element' );
				} else {
					this.debugInfo( '[CanvasManager] Using existing canvas in container' );
				}
			} else {
				throw new Error( 'No container or canvas provided for CanvasManager initialization' );
			}

			// Validate canvas element
			if ( !this.canvas || !this.canvas.getContext ) {
				throw new Error( 'Invalid canvas element - cannot get context' );
			}

			// Get 2D context
			this.ctx = this.canvas.getContext( '2d' );
			if ( !this.ctx ) {
				throw new Error( 'Failed to get 2D context from canvas' );
			}

			// Set canvas attributes for better rendering
			this.canvas.style.display = 'block';
			this.canvas.setAttribute( 'tabindex', '0' ); // Make focusable for keyboard events

			this.debugInfo( '[CanvasManager] Canvas initialized successfully' );
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Canvas initialization failed:', error );
			throw new Error( 'Canvas initialization failed: ' + error.message );
		}
	};

	/**
	 * Initialize all modular components with better error handling
	 */
	CanvasManager.prototype.initModules = function () {
		try {
			const moduleConfig = {
				editor: this.editor,
				canvas: this.canvas,
				canvasManager: this
			};

			this.debugInfo( '[CanvasManager] Initializing modules with config:', moduleConfig );

			// Get or create module registry
			this.registry = window.layersRegistry || window.layersModuleRegistry;
			if ( !this.registry ) {
				this.debugInfo( '[CanvasManager] No module registry found, using legacy initialization' );
				this.initModulesLegacy();
				return;
			}

			// Track initialization status
			const moduleStatus = {
				renderingCore: false,
				layerRenderer: false,
				transformationEngine: false,
				eventSystem: false,
				selectionSystem: false,
				toolManager: false
			};

			// Validate canvas is properly initialized before creating modules
			if ( !this.canvas || !this.ctx ) {
				throw new Error( 'Canvas or context not initialized before module creation' );
			}

			// Register module factories with the registry
			if ( this.registry.register ) {
				this.registry.register( 'RenderingCore', () => {
					if ( window.RenderingCore ) {
						return new window.RenderingCore( this.canvas, moduleConfig );
					}
					return null;
				}, [] );

				this.registry.register( 'LayerRenderer', () => {
					if ( window.LayerRenderer ) {
						return new window.LayerRenderer( this.ctx, moduleConfig );
					}
					return null;
				}, [] );

				this.registry.register( 'TransformationEngine', () => {
					if ( window.TransformationEngine ) {
						return new window.TransformationEngine( this.canvas, moduleConfig );
					}
					return null;
				}, [] );
			}

			// Initialize modules through registry
			try {
				this.renderingCore = this.registry.get( 'RenderingCore' );
				moduleStatus.renderingCore = !!this.renderingCore;
			} catch ( error ) {
				this.debugInfo( '[CanvasManager] RenderingCore initialization failed:', error );
			}

			try {
				this.layerRenderer = this.registry.get( 'LayerRenderer' );
				moduleStatus.layerRenderer = !!this.layerRenderer;
			} catch ( error ) {
				this.debugInfo( '[CanvasManager] LayerRenderer initialization failed:', error );
			}

			try {
				this.transformationEngine = this.registry.get( 'TransformationEngine' );
				if ( this.transformationEngine ) {
					this.syncTransformProperties();
					moduleStatus.transformationEngine = true;
				}
			} catch ( error ) {
				this.debugInfo( '[CanvasManager] TransformationEngine initialization failed:', error );
			}

			// Initialize EventSystem (critical for user interaction)
			try {
				if ( this.registry.register ) {
					this.registry.register( 'EventSystem', () => {
						if ( window.EventSystem ) {
							return new window.EventSystem( this.canvas, moduleConfig );
						}
						return null;
					}, [] );
				}
				this.eventSystem = this.registry.get( 'EventSystem' );
				if ( this.eventSystem ) {
					this.setupEventCallbacks();
					moduleStatus.eventSystem = true;
				}
			} catch ( error ) {
				this.debugInfo( '[CanvasManager] EventSystem initialization failed:', error );
			}

			// Initialize SelectionSystem (important for layer management)
			try {
				this.initializeSelectionSystem();
				moduleStatus.selectionSystem = !!this.selectionSystem;
			} catch ( error ) {
				this.debugInfo( '[CanvasManager] SelectionSystem initialization failed:', error );
			}

			// Initialize ToolManager (important for tool operations)
			try {
				if ( this.registry.register ) {
					this.registry.register( 'ToolManager', () => {
						if ( window.ToolManager ) {
							return new window.ToolManager( moduleConfig, this );
						} else if ( window.LayersToolManager ) {
							return new window.LayersToolManager( moduleConfig, this );
						}
						return null;
					}, [] );
				}
				this.toolManager = this.registry.get( 'ToolManager' );
				moduleStatus.toolManager = !!this.toolManager;
			} catch ( error ) {
				this.debugInfo( '[CanvasManager] ToolManager initialization failed:', error );
			}

			this.debugInfo( '[CanvasManager] Module initialization status:', moduleStatus );

			// Validate critical modules
			if ( !moduleStatus.eventSystem ) {
				this.debugInfo( '[CanvasManager] Warning: EventSystem not initialized - user interaction may be limited' );
			}

			if ( !moduleStatus.transformationEngine ) {
				this.debugInfo( '[CanvasManager] Warning: TransformationEngine not initialized - zoom/pan may not work' );
			}

		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Module initialization failed:', error );
			throw new Error( 'Module initialization failed: ' + error.message );
		}
	};

	/**
	 * Legacy module initialization for backwards compatibility
	 */
	CanvasManager.prototype.initModulesLegacy = function () {
		const moduleConfig = {
			editor: this.editor,
			canvas: this.canvas,
			canvasManager: this
		};

		// Track initialization status
		const moduleStatus = {
			renderingCore: false,
			layerRenderer: false,
			transformationEngine: false,
			eventSystem: false,
			selectionSystem: false,
			toolManager: false
		};

		// Initialize modules using legacy method
		try {
			if ( this.isModuleAvailable( 'RenderingCore' ) ) {
				this.renderingCore = this.createModule( 'RenderingCore', [ this.canvas, moduleConfig ] );
				moduleStatus.renderingCore = !!this.renderingCore;
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] RenderingCore initialization failed:', error );
		}

		try {
			if ( this.isModuleAvailable( 'LayerRenderer' ) ) {
				this.layerRenderer = this.createModule( 'LayerRenderer', [ this.ctx, moduleConfig ] );
				moduleStatus.layerRenderer = !!this.layerRenderer;
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] LayerRenderer initialization failed:', error );
		}

		try {
			if ( this.isModuleAvailable( 'TransformationEngine' ) ) {
				this.transformationEngine = this.createModule( 'TransformationEngine', [ this.canvas, moduleConfig ] );
				if ( this.transformationEngine ) {
					this.syncTransformProperties();
					moduleStatus.transformationEngine = true;
				}
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] TransformationEngine initialization failed:', error );
		}

		try {
			if ( this.isModuleAvailable( 'EventSystem' ) ) {
				this.eventSystem = this.createModule( 'EventSystem', [ this.canvas, moduleConfig ] );
				if ( this.eventSystem ) {
					this.setupEventCallbacks();
					moduleStatus.eventSystem = true;
				}
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] EventSystem initialization failed:', error );
		}

		try {
			this.initializeSelectionSystem();
			moduleStatus.selectionSystem = !!this.selectionSystem;
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] SelectionSystem initialization failed:', error );
		}

		try {
			if ( this.isModuleAvailable( 'ToolManager' ) || this.isModuleAvailable( 'LayersToolManager' ) ) {
				const toolManagerName = this.isModuleAvailable( 'ToolManager' ) ? 'ToolManager' : 'LayersToolManager';
				this.toolManager = this.createModule( toolManagerName, [ moduleConfig, this ] );
				moduleStatus.toolManager = !!this.toolManager;
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] ToolManager initialization failed:', error );
		}

		this.debugInfo( '[CanvasManager] Legacy module initialization status:', moduleStatus );
	};

	/**
	 * Check if a module is available in the global scope
	 * @param {string} moduleName Name of the module to check
	 * @return {boolean} True if module is available
	 */
	CanvasManager.prototype.isModuleAvailable = function ( moduleName ) {
		return (
			( typeof window !== 'undefined' && typeof window[ moduleName ] === 'function' ) ||
			( typeof mw !== 'undefined' && typeof mw[ moduleName ] === 'function' )
		);
	};

	/**
	 * Create a module instance safely
	 * @param {string} moduleName Name of the module
	 * @param {Array} args Arguments to pass to constructor
	 * @return {Object|null} Module instance or null if creation failed
	 */
	CanvasManager.prototype.createModule = function ( moduleName, args ) {
		try {
			let ModuleConstructor = null;

			// Try window scope first
			if ( typeof window !== 'undefined' && typeof window[ moduleName ] === 'function' ) {
				ModuleConstructor = window[ moduleName ];
			}
			// Try mw scope
			else if ( typeof mw !== 'undefined' && typeof mw[ moduleName ] === 'function' ) {
				ModuleConstructor = mw[ moduleName ];
			}

			if ( ModuleConstructor ) {
				return new ( ModuleConstructor.bind.apply( ModuleConstructor, [ null ].concat( args ) ) )();
			}

			return null;
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Failed to create module', moduleName, ':', error );
			return null;
		}
	};

	/**
	 * Initialize the selection system with better error handling
	 */
	CanvasManager.prototype.initializeSelectionSystem = function () {
		if ( this.selectionSystem ) {
			// Already initialized
			this.debugInfo( '[CanvasManager] SelectionSystem already initialized' );
			return;
		}

		try {
			// Look for LayersSelectionManager in multiple locations
			let SelectionSystemCtor = null;

			if ( typeof window !== 'undefined' && typeof window.LayersSelectionManager === 'function' ) {
				SelectionSystemCtor = window.LayersSelectionManager;
			} else if ( typeof mw !== 'undefined' && mw.LayersSelectionManager ) {
				SelectionSystemCtor = mw.LayersSelectionManager;
			} else if ( typeof require === 'function' ) {
				// Allow Jest/CommonJS to load the module directly
				try {
					SelectionSystemCtor = require( './SelectionManager.js' );
				} catch ( e ) {
					this.debugInfo( '[CanvasManager] SelectionManager module not found via require:', e );
				}
			}

			if ( typeof SelectionSystemCtor === 'function' ) {
				this.selectionSystem = new SelectionSystemCtor( this.config, this );
				// Back-compat bridge: expose as selectionManager for legacy code
				this.selectionManager = this.selectionSystem;
				this.debugInfo( '[CanvasManager] SelectionSystem initialized successfully' );
			} else {
				this.debugInfo( '[CanvasManager] SelectionManager not found, selection features will be disabled' );
				// Create a minimal fallback selection system
				this.createFallbackSelectionSystem();
			}
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] SelectionSystem initialization failed:', error );
			this.createFallbackSelectionSystem();
		}
	};

	/**
	 * Create a minimal fallback selection system when the full system is not available
	 */
	CanvasManager.prototype.createFallbackSelectionSystem = function () {
		this.selectionSystem = {
			getSelectedLayers: function () { return []; },
			selectLayer: function () { return false; },
			clearSelection: function () { return true; },
			isLayerSelected: function () { return false; }
		};
		this.selectionManager = this.selectionSystem;
		this.debugInfo( '[CanvasManager] Fallback selection system created' );
	};

	/**
	 * Sync transformation properties from TransformationEngine
	 */
	CanvasManager.prototype.syncTransformProperties = function () {
		if ( this.transformationEngine ) {
			this.zoom = this.transformationEngine.getZoom();
			const pan = this.transformationEngine.getPan();
			this.panX = pan.x;
			this.panY = pan.y;
		}
	};

	/**
	 * Update base dimensions for coordinate scaling
	 *
	 * @param {number|null} baseWidth Original image width
	 * @param {number|null} baseHeight Original image height
	 */
	CanvasManager.prototype.setBaseDimensions = function ( baseWidth, baseHeight ) {
		// Ensure positive dimensions to prevent division by zero and scaling issues
		if ( !baseWidth || baseWidth <= 0 ) {
			baseWidth = 100;
		}
		if ( !baseHeight || baseHeight <= 0 ) {
			baseHeight = 100;
		}

		this.baseWidth = baseWidth;
		this.baseHeight = baseHeight;

		this.debugInfo( '[CanvasManager] Base dimensions set:', { baseWidth: baseWidth, baseHeight: baseHeight } );

		// Calculate background image rect now that we have base dimensions
		this.calculateBackgroundImageRect();
	};

	/**
	 * Scale layer coordinates from base dimensions to current canvas size
	 *
	 * @param {Object} layer Original layer object
	 * @return {Object} Layer object with scaled coordinates
	 */
	CanvasManager.prototype.scaleLayerCoordinates = function ( layer ) {
		// If no base dimensions, return layer as-is
		if ( !this.baseWidth || !this.baseHeight ) {
			this.debugInfo( '[CanvasManager] scaleLayerCoordinates: No base dimensions set, returning layer unchanged' );
			return layer;
		}

		// Ensure backgroundImageRect is calculated if not set
		if ( !this.backgroundImageRect ) {
			this.calculateBackgroundImageRect();
		}

		// If still no backgroundImageRect, return layer unchanged
		if ( !this.backgroundImageRect ) {
			this.debugInfo( '[CanvasManager] scaleLayerCoordinates: No background image rect, returning layer unchanged' );
			return layer;
		}

		// Use the stored background image rect for scaling
		const sx = this.backgroundImageRect.width / this.baseWidth;
		const sy = this.backgroundImageRect.height / this.baseHeight;
		const offsetX = this.backgroundImageRect.x + this.panX;
		const offsetY = this.backgroundImageRect.y + this.panY;

		this.debugInfo( '[CanvasManager] scaleLayerCoordinates: Using scale factors:', { sx: sx, sy: sy }, 'and offset:', { x: offsetX, y: offsetY } );
		this.debugInfo( '[CanvasManager] scaleLayerCoordinates: Base dimensions:', this.baseWidth + 'x' + this.baseHeight, 'Image Rect:', this.backgroundImageRect.width + 'x' + this.backgroundImageRect.height, 'Zoom:', this.zoom, 'Pan:', this.panX, this.panY );

		// Create a scaled copy of the layer
		const scaledLayer = {};
		for ( const k in layer ) {
			if ( Object.prototype.hasOwnProperty.call( layer, k ) ) {
				scaledLayer[ k ] = layer[ k ];
			}
		}

		// Scale coordinate properties and apply offset
		if ( typeof scaledLayer.x === 'number' ) {
			scaledLayer.x = scaledLayer.x * sx + offsetX;
		}
		if ( typeof scaledLayer.y === 'number' ) {
			scaledLayer.y = scaledLayer.y * sy + offsetY;
		}
		if ( typeof scaledLayer.width === 'number' ) {
			scaledLayer.width = scaledLayer.width * sx;
		}
		if ( typeof scaledLayer.height === 'number' ) {
			scaledLayer.height = scaledLayer.height * sy;
		}
		if ( typeof scaledLayer.radius === 'number' ) {
			scaledLayer.radius = scaledLayer.radius * ( ( sx + sy ) / 2 );
		}
		if ( typeof scaledLayer.radiusX === 'number' ) {
			scaledLayer.radiusX = scaledLayer.radiusX * sx;
		}
		if ( typeof scaledLayer.radiusY === 'number' ) {
			scaledLayer.radiusY = scaledLayer.radiusY * sy;
		}
		if ( typeof scaledLayer.x1 === 'number' ) {
			scaledLayer.x1 = scaledLayer.x1 * sx + offsetX;
		}
		if ( typeof scaledLayer.y1 === 'number' ) {
			scaledLayer.y1 = scaledLayer.y1 * sy + offsetY;
		}
		if ( typeof scaledLayer.x2 === 'number' ) {
			scaledLayer.x2 = scaledLayer.x2 * sx + offsetX;
		}
		if ( typeof scaledLayer.y2 === 'number' ) {
			scaledLayer.y2 = scaledLayer.y2 * sy + offsetY;
		}
		// Scale stroke width and other size-related properties
		if ( typeof scaledLayer.strokeWidth === 'number' ) {
			scaledLayer.strokeWidth = scaledLayer.strokeWidth * ( ( sx + sy ) / 2 );
		}
		if ( typeof scaledLayer.fontSize === 'number' ) {
			scaledLayer.fontSize = scaledLayer.fontSize * ( ( sx + sy ) / 2 );
		}
		// Scale shadow properties
		if ( typeof scaledLayer.shadowBlur === 'number' ) {
			scaledLayer.shadowBlur = scaledLayer.shadowBlur * ( ( sx + sy ) / 2 );
		}
		if ( typeof scaledLayer.shadowOffsetX === 'number' ) {
			scaledLayer.shadowOffsetX = scaledLayer.shadowOffsetX * sx;
		}
		if ( typeof scaledLayer.shadowOffsetY === 'number' ) {
			scaledLayer.shadowOffsetY = scaledLayer.shadowOffsetY * sy;
		}
		// Scale points array for polygons/paths
		if ( Array.isArray( scaledLayer.points ) ) {
			scaledLayer.points = scaledLayer.points.map( ( point ) => ( {
				x: point.x * sx + offsetX,
				y: point.y * sy + offsetY
			} ) );
		}

		this.debugInfo( '[CanvasManager] scaleLayerCoordinates: Scaled layer result:', {
			id: scaledLayer.id,
			x: scaledLayer.x,
			y: scaledLayer.y,
			width: scaledLayer.width,
			height: scaledLayer.height
		} );

		return scaledLayer;
	};

	/**
	 * Calculate background image rect based on canvas size and base dimensions
	 */
	CanvasManager.prototype.calculateBackgroundImageRect = function () {
		if ( !this.baseWidth || !this.baseHeight ) {
			return;
		}

		// Use stored canvas dimensions if available, otherwise get from canvas
		const canvasWidth = this.canvasWidth || ( this.canvas ? this.canvas.width : 0 );
		const canvasHeight = this.canvasHeight || ( this.canvas ? this.canvas.height : 0 );

		if ( canvasWidth <= 0 || canvasHeight <= 0 ) {
			this.debugInfo( '[CanvasManager] calculateBackgroundImageRect: Invalid canvas dimensions:', canvasWidth + 'x' + canvasHeight );
			return;
		}

		const imgWidth = this.baseWidth;
		const imgHeight = this.baseHeight;

		const canvasAspect = canvasWidth / canvasHeight;
		const imgAspect = imgWidth / imgHeight;

		let drawWidth, drawHeight, x, y;

		if ( canvasAspect > imgAspect ) {
			// Canvas is wider than the image, so fit to height
			drawHeight = canvasHeight;
			drawWidth = drawHeight * imgAspect;
			x = ( canvasWidth - drawWidth ) / 2;
			y = 0;
		} else {
			// Canvas is taller than or same aspect as the image, so fit to width
			drawWidth = canvasWidth;
			drawHeight = drawWidth / imgAspect;
			x = 0;
			y = ( canvasHeight - drawHeight ) / 2;
		}

		// Store the calculated rect
		this.backgroundImageRect = { x: x, y: y, width: drawWidth, height: drawHeight };

		this.debugInfo( '[CanvasManager] calculateBackgroundImageRect: Calculated rect:', this.backgroundImageRect, 'for canvas', canvasWidth + 'x' + canvasHeight, 'and base dimensions', imgWidth + 'x' + imgHeight );
	};
	CanvasManager.prototype.setupEventCallbacks = function () {
		if ( !this.eventSystem ) {
			this.debugInfo( '[CanvasManager] setupEventCallbacks called but no EventSystem available' );
			return;
		}

		this.debugInfo( '[CanvasManager] Setting up event callbacks for EventSystem' );

		// Update EventSystem configuration to include CanvasManager reference (guarded)
		if ( typeof this.eventSystem.updateConfig === 'function' ) {
			this.eventSystem.updateConfig( {
				canvasManager: this
			} );
		}

		const self = this;

		// Set up event callbacks
		this.eventSystem.on( 'mouseDown', ( e, point ) => {
			// Mouse down event
			self.handleMouseDown( e, point );
		} );

		this.eventSystem.on( 'mouseMove', ( e, point ) => {
			// Mouse move event - removed debug logging for performance
			self.handleMouseMove( e, point );
		} );

		this.eventSystem.on( 'mouseUp', ( e, point ) => {
			// Mouse up event
			self.handleMouseUp( e, point );
		} );

		this.eventSystem.on( 'doubleClick', ( e, point ) => {
			this.debugInfo( '[CanvasManager] doubleClick event received:', point );
			self.handleDoubleClick( e, point );
		} );

		this.eventSystem.on( 'wheel', ( e ) => {
			this.debugInfo( '[CanvasManager] wheel event received:', e.deltaY );
			self.handleWheel( e );
		} );

		this.eventSystem.on( 'keyDown', ( e ) => {
			// Key down event
			self.handleKeyDown( e );
		} );

		this.eventSystem.on( 'keyUp', ( e ) => {
			// Key up event
			self.handleKeyUp( e );
		} );

		this.debugInfo( '[CanvasManager] Event callbacks setup completed' );
	};

	/**
	 * Set up event handlers (maintains backward compatibility)
	 */
	CanvasManager.prototype.setupEventHandlers = function () {
		this.debugInfo( '[CanvasManager] setupEventHandlers called' );

		// EventSystem is already initialized in initModules()
		// This method kept for backward compatibility and to ensure proper setup
		if ( !this.eventSystem ) {
			this.debugInfo( '[CanvasManager] EventSystem not initialized, trying to initialize...' );

			// Try to initialize EventSystem if it wasn't available during initModules
			if ( typeof window.EventSystem !== 'undefined' ) {
				this.debugInfo( '[CanvasManager] Initializing EventSystem from window.EventSystem' );
				this.eventSystem = new window.EventSystem( this.canvas, {
					editor: this.editor,
					canvasManager: this
				} );
				// Set up event callbacks
				this.setupEventCallbacks();
			} else if ( typeof mw !== 'undefined' && mw.EventSystem ) {
				this.debugInfo( '[CanvasManager] Initializing EventSystem from mw.EventSystem' );
				this.eventSystem = new mw.EventSystem( this.canvas, {
					editor: this.editor,
					canvasManager: this
				} );
				// Set up event callbacks
				this.setupEventCallbacks();
			} else {
				// Log warning if EventSystem is still not available
				this.debugInfo( '[CanvasManager] EventSystem not available - checking availability:' );
				this.debugInfo( '[CanvasManager] window.EventSystem:', typeof window.EventSystem );
				this.debugInfo( '[CanvasManager] mw.EventSystem:', typeof mw !== 'undefined' ? mw.EventSystem : 'mw undefined' );
				if ( typeof mw !== 'undefined' && mw.log ) {
					mw.log.warn( 'EventSystem not available during setupEventHandlers - canvas events may not work properly' );
				}
			}
		} else {
			this.debugInfo( '[CanvasManager] EventSystem already initialized, updating config' );
			// Ensure EventSystem has the correct CanvasManager reference
			if ( typeof this.eventSystem.updateConfig === 'function' ) {
				this.eventSystem.updateConfig( {
					canvasManager: this
				} );
			}
		}

		// Ensure TransformationEngine is available for zoom/pan
		if ( !this.transformationEngine ) {
			this.debugInfo( '[CanvasManager] TransformationEngine not initialized, trying to initialize...' );

			// Try to initialize TransformationEngine if it wasn't available during initModules
			if ( typeof window.TransformationEngine !== 'undefined' ) {
				this.debugInfo( '[CanvasManager] Initializing TransformationEngine from window.TransformationEngine' );
				this.transformationEngine = new window.TransformationEngine( this.canvas, {
					editor: this.editor,
					canvasManager: this
				} );
			} else if ( typeof mw !== 'undefined' && mw.TransformationEngine ) {
				this.debugInfo( '[CanvasManager] Initializing TransformationEngine from mw.TransformationEngine' );
				this.transformationEngine = new mw.TransformationEngine( this.canvas, {
					editor: this.editor,
					canvasManager: this
				} );
			} else {
				// Log warning if TransformationEngine is still not available
				this.debugInfo( '[CanvasManager] TransformationEngine not available - checking availability:' );
				this.debugInfo( '[CanvasManager] window.TransformationEngine:', typeof window.TransformationEngine );
				this.debugInfo( '[CanvasManager] mw.TransformationEngine:', typeof mw !== 'undefined' ? mw.TransformationEngine : 'mw undefined' );
				if ( typeof mw !== 'undefined' && mw.log ) {
					mw.log.warn( 'TransformationEngine not available during setupEventHandlers - zoom/pan may not work properly' );
				}
			}
		} else {
			this.debugInfo( '[CanvasManager] TransformationEngine already initialized' );
		}
	};

	/**
	 * Load background image for the canvas
	 */
	CanvasManager.prototype.loadBackgroundImage = function ( backgroundImageUrl ) {
		this.debugInfo( '[CanvasManager] loadBackgroundImage called with URL:', backgroundImageUrl );
		this.debugInfo( '[CanvasManager] loadBackgroundImage - editor filename:', this.editor ? this.editor.filename : 'N/A' );

		const filename = this.editor.filename;
		const imageUrls = [];

		// Priority 1: Use specific background image URL from parameter or config
		if ( backgroundImageUrl ) {
			imageUrls.push( backgroundImageUrl );
		} else if ( this.config.backgroundImageUrl ) {
			imageUrls.push( this.config.backgroundImageUrl );
		}

		// Priority 2: Try to find current page image
		const pageImages = document.querySelectorAll(
			'.mw-file-element img, .fullImageLink img, .filehistory img, img[src*="' + filename + '"]'
		);
		this.debugInfo( '[CanvasManager] loadBackgroundImage - Found', pageImages.length, 'page images' );
		if ( pageImages.length > 0 ) {
			for ( let i = 0; i < pageImages.length; i++ ) {
				const imgSrc = pageImages[ i ].src;
				if ( imgSrc && !imageUrls.includes( imgSrc ) ) {
					imageUrls.push( imgSrc );
				}
			}
		}

		// Priority 3: Try MediaWiki patterns if available
		if ( filename && typeof mw !== 'undefined' && mw.config ) {
			const title = filename.replace( /^File:/, '' );
			const serverUrl = mw.config.get( 'wgServer' );
			const scriptPath = mw.config.get( 'wgScriptPath' );

			if ( serverUrl && scriptPath ) {
				const wikiUrl = serverUrl + scriptPath + '/index.php?title=File:' +
					encodeURIComponent( title );
				imageUrls.push( wikiUrl );
			}
		}

		this.debugInfo( '[CanvasManager] loadBackgroundImage - Final image URLs to try:', imageUrls );

		this.tryLoadImageUrls( imageUrls );
	};

	/**
	 * Try loading image URLs in sequence
	 *
	 * @param {Array} urls - Array of image URLs to try
	 */
	CanvasManager.prototype.tryLoadImageUrls = function ( urls ) {
		this.debugInfo( '[CanvasManager] tryLoadImageUrls called with' , urls.length, 'URLs:', urls );

		if ( urls.length === 0 ) {
			this.debugInfo( '[CanvasManager] No URLs to try, background image will not load' );
			this.onBackgroundImageLoad( null );
			return;
		}

		const self = this;
		const img = new Image();
		const currentUrl = urls.shift();

		this.debugInfo( '[CanvasManager] Trying to load background image from:', currentUrl );

		img.onload = function () {
			self.debugInfo( '[CanvasManager] Background image loaded successfully from:', currentUrl, 'dimensions:', img.naturalWidth + 'x' + img.naturalHeight );
			self.onBackgroundImageLoad( img );
		};

		img.onerror = function () {
			self.debugInfo( '[CanvasManager] Failed to load background image from:', currentUrl, 'trying next URL' );
			// Try next URL
			self.tryLoadImageUrls( urls );
		};

		img.crossOrigin = 'anonymous';
		img.src = currentUrl;
	};

	/**
	 * Handle successful background image load
	 *
	 * @param {Image|null} img - Loaded image or null if failed
	 */
	CanvasManager.prototype.onBackgroundImageLoad = function ( img ) {
		this.debugInfo( '[CanvasManager] onBackgroundImageLoad called with image:', img ? 'loaded' : 'null' );

		this.backgroundImage = img;

		// Propagate background image to RenderingCore
		if ( this.renderingCore ) {
			this.renderingCore.backgroundImage = img;
		}

		if ( img ) {
			// Mark background image as changed for dirty region optimization
			this.backgroundImageChanged = true;
			this.resizeCanvas();
			// Removed automatic fitToWindow to prevent unexpected zoom changes
			// User should manually zoom if needed
		}

		this.redraw();

		// Get layers from state manager if available
		if ( this.editor && this.editor.stateManager ) {
			const layers = this.editor.stateManager.get( 'layers' ) || [];
			if ( layers.length > 0 ) {
				this.renderLayers( layers );
			}
		} else if ( this.editor && this.editor.layers ) {
			// Fallback for backward compatibility
			this.renderLayers( this.editor.layers );
		}
	};

	/**
	 * Resize canvas to fit container
	 */
	CanvasManager.prototype.resizeCanvas = function () {
		if ( !this.canvas || !this.container ) {
			return;
		}

		const containerRect = this.container.getBoundingClientRect();
		const newWidth = Math.max( 100, containerRect.width - 20 );
		const newHeight = Math.max( 100, containerRect.height - 20 );

		// Only resize if dimensions have actually changed or canvas has no dimensions
		if ( this.canvas.width !== newWidth || this.canvas.height !== newHeight ||
			!this.canvas.width || !this.canvas.height ) {

			this.debugInfo( '[CanvasManager] resizeCanvas: Resizing from', this.canvas.width + 'x' + this.canvas.height, 'to', newWidth + 'x' + newHeight );
			this.debugInfo( '[CanvasManager] resizeCanvas: Container dimensions:', containerRect.width + 'x' + containerRect.height );

			this.canvas.width = newWidth;
			this.canvas.height = newHeight;
			this.canvas.style.width = newWidth + 'px';
			this.canvas.style.height = newHeight + 'px';

			// Store the canvas dimensions for use in calculations
			this.canvasWidth = newWidth;
			this.canvasHeight = newHeight;

			// Mark canvas size as changed for dirty region optimization
			this.canvasSizeChanged = true;

			// Update transformation engine viewport
			if ( this.transformationEngine ) {
				this.transformationEngine.updateViewportBounds();
			}

			// Calculate background image rect if we have base dimensions
			if ( this.baseWidth && this.baseHeight ) {
				this.calculateBackgroundImageRect();
			}

			this.redraw();
		}
	};

	/**
	 * Handle canvas resize externally
	 */
	CanvasManager.prototype.handleCanvasResize = function () {
		this.resizeCanvas();
		if ( this.transformationEngine ) {
			this.transformationEngine.updateCanvasTransform();
		}
		// Get layers from state manager if available
		if ( this.editor && this.editor.stateManager ) {
			const layers = this.editor.stateManager.get( 'layers' ) || [];
			this.renderLayers( layers );
		} else if ( this.editor && this.editor.layers ) {
			// Fallback for backward compatibility
			this.renderLayers( this.editor.layers );
		}
	};

	/**
	 * Redraw the entire canvas
	 */
	CanvasManager.prototype.redraw = function () {
		if ( this.redrawScheduled ) {
			return;
		}

		this.redrawScheduled = true;
		const self = this;

		requestAnimationFrame( () => {
			self.performRedraw();
			self.redrawScheduled = false;
		} );
	};

	/**
	 * Perform the actual redraw operation with performance optimizations
	 */
	CanvasManager.prototype.performRedraw = function () {
		if ( !this.ctx ) {
			this.debugInfo( '[CanvasManager] No canvas context available for redraw' );
			return;
		}

		// Check if we need a full redraw or can use dirty region optimization
		const needsFullRedraw = this.needsFullRedraw();
		const dirtyRegions = needsFullRedraw ? null : this.getDirtyRegions();

		this.debugInfo( '[CanvasManager] performRedraw: Full redraw:', needsFullRedraw, 'Dirty regions:', dirtyRegions ? dirtyRegions.length : 'N/A' );

		// Clear canvas or dirty regions
		if ( needsFullRedraw ) {
			this.ctx.clearRect( 0, 0, this.canvas.width, this.canvas.height );
		} else if ( dirtyRegions && dirtyRegions.length > 0 ) {
			// Clear only dirty regions with padding for anti-aliasing
			const padding = 2;
			dirtyRegions.forEach( region => {
				this.ctx.clearRect(
					region.x - padding,
					region.y - padding,
					region.width + 2 * padding,
					region.height + 2 * padding
				);
			} );
		}

		// Save canvas state and apply transformations
		this.ctx.save();

		// Sync transformation properties first
		this.syncTransformProperties();

		// Apply canvas transformations (zoom and pan)
		this.ctx.translate( this.panX || 0, this.panY || 0 );
		this.ctx.scale( this.zoom || 1, this.zoom || 1 );

		this.debugInfo( '[CanvasManager] performRedraw: Applied transformations - pan:', this.panX, this.panY, 'zoom:', this.zoom );

		// Draw background image if available
		if ( this.backgroundImage ) {
			this.debugInfo( '[CanvasManager] performRedraw: Drawing background image' );
			if ( this.renderingCore && typeof this.renderingCore.drawBackgroundImage === 'function' ) {
				// Use modular RenderingCore (already has backgroundImage reference)
				this.renderingCore.drawBackgroundImage();
			} else {
				// Fallback: Draw background image directly
				this.drawBackgroundImageBasic( this.backgroundImage );
			}
		} else {
			this.debugInfo( '[CanvasManager] performRedraw: No background image to draw' );
		}

		// Draw grid if enabled
		if ( this.showGrid && this.renderingCore && this.renderingCore.drawGrid ) {
			// Update RenderingCore grid properties
			this.renderingCore.setGridProperties( this.showGrid, this.gridSize, this.gridColor );
			this.renderingCore.drawGrid();
		}

		// Draw rulers if enabled
		if ( this.showRulers && this.renderingCore && this.renderingCore.drawRulers ) {
			// Update RenderingCore ruler properties
			this.renderingCore.setRulerProperties(
				this.showRulers,
				this.rulerSize,
				this.rulerColor,
				this.rulerTextColor
			);
			this.renderingCore.drawRulers();
		}

		// Draw guides if enabled
		if ( this.showGuides && this.renderingCore && this.renderingCore.drawGuides ) {
			this.renderingCore.drawGuides( this.horizontalGuides, this.verticalGuides );
		}

		// Draw layers if available (this should happen after background)
		if ( this.editor && this.editor.stateManager ) {
			const layers = this.editor.stateManager.get( 'layers' ) || [];
			if ( layers.length > 0 ) {
				this.debugInfo( '[CanvasManager] performRedraw: Drawing', layers.length, 'layers from state manager' );
				// Render layers only (selection will be drawn after restore)
				this.renderLayers( layers );
			} else {
				this.debugInfo( '[CanvasManager] performRedraw: No layers to draw (from state manager)' );
			}
		} else if ( this.editor && this.editor.layers && this.editor.layers.length > 0 ) {
			// Fallback to direct editor.layers for backward compatibility
			this.debugInfo( '[CanvasManager] performRedraw: Drawing', this.editor.layers.length, 'layers from editor.layers (fallback)' );
			this.renderLayers( this.editor.layers );
		} else {
			this.debugInfo( '[CanvasManager] performRedraw: No layers to draw' );
		}

		// Restore canvas state BEFORE drawing selection (selection in screen space, not world space)
		this.ctx.restore();

		// Draw selection indicators in screen space (after restore)
		// Apply transformations again for selection drawing in world coordinates
		this.ctx.save();
		this.ctx.translate( this.panX || 0, this.panY || 0 );
		this.ctx.scale( this.zoom || 1, this.zoom || 1 );
		this.drawSelectionIndicators();
		this.ctx.restore();

		// Clear dirty regions after successful redraw
		this.clearDirtyRegions();

		this.debugInfo( '[CanvasManager] performRedraw: Canvas state restored, redraw complete' );
	};

	/**
	 * Check if a full redraw is needed
	 *
	 * @return {boolean} True if full redraw is required
	 */
	CanvasManager.prototype.needsFullRedraw = function () {
		// Full redraw needed if:
		// - No dirty regions tracked yet
		// - Background image changed
		// - Canvas size changed
		// - Zoom/pan changed significantly
		// - Grid/rulers/guides toggled
		return !this.dirtyRegions ||
			this.dirtyRegions.length === 0 ||
			this.backgroundImageChanged ||
			this.canvasSizeChanged ||
			this.transformChanged ||
			this.gridChanged ||
			this.rulersChanged ||
			this.guidesChanged;
	};

	/**
	 * Get current dirty regions that need redrawing
	 *
	 * @return {Array} Array of dirty region objects {x, y, width, height}
	 */
	CanvasManager.prototype.getDirtyRegions = function () {
		return this.dirtyRegions || [];
	};

	/**
	 * Clear dirty regions after successful redraw
	 */
	CanvasManager.prototype.clearDirtyRegions = function () {
		this.dirtyRegions = [];
		this.backgroundImageChanged = false;
		this.canvasSizeChanged = false;
		this.transformChanged = false;
		this.gridChanged = false;
		this.rulersChanged = false;
		this.guidesChanged = false;
	};

	/**
	 * Mark a region as dirty
	 *
	 * @param {Object} region - Region object {x, y, width, height}
	 */
	CanvasManager.prototype.markDirtyRegion = function ( region ) {
		if ( !this.dirtyRegions ) {
			this.dirtyRegions = [];
		}

		// Add padding for anti-aliasing and safety
		const padding = 4;
		const paddedRegion = {
			x: region.x - padding,
			y: region.y - padding,
			width: region.width + 2 * padding,
			height: region.height + 2 * padding
		};

		this.dirtyRegions.push( paddedRegion );
	};

	/**
	 * Mark entire canvas as dirty (force full redraw)
	 */
	CanvasManager.prototype.markCanvasDirty = function () {
		this.isDirty = true;
	};

	/**
	 * Mark layer region as dirty
	 *
	 * @param {Object} layer - Layer object
	 */
	CanvasManager.prototype.markLayerDirty = function ( layer ) {
		if ( !layer ) {
			return;
		}

		const bounds = this.getLayerBounds( layer );
		if ( bounds ) {
			this.markDirtyRegion( bounds );
		}
	};

	/**
	 * Optimized layer rendering with dirty region support
	 *
	 * @param {Array} layers - Array of layer objects
	 * @param {Array} dirtyRegions - Array of dirty regions
	 * @param {boolean} needsFullRedraw - Whether full redraw is needed
	 */
	CanvasManager.prototype.renderLayersOptimized = function ( layers, dirtyRegions, needsFullRedraw ) {
		if ( !layers || layers.length === 0 ) {
			this.debugInfo( '[CanvasManager] renderLayersOptimized called with no layers' );
			return;
		}

		this.debugInfo( '[CanvasManager] renderLayersOptimized called with', layers.length, 'layers' );

		// For full redraw, use existing renderLayers method
		if ( needsFullRedraw ) {
			this.renderLayers( layers );
			return;
		}

		// For partial redraw, only render layers that intersect with dirty regions
		const layersToRender = this.getLayersInDirtyRegions( layers, dirtyRegions );

		if ( layersToRender.length === 0 ) {
			this.debugInfo( '[CanvasManager] No layers need rendering in dirty regions' );
			return;
		}

		this.debugInfo( '[CanvasManager] Rendering', layersToRender.length, 'layers in dirty regions' );

		// Render each layer using appropriate renderer
		// Render in reverse order so that layers at the top of the list appear on top
		for ( let i = layersToRender.length - 1; i >= 0; i-- ) {
			const layer = layersToRender[ i ];
			this.debugInfo( '[CanvasManager] Rendering layer', layer.id, ':', layer.type, 'visible:', layer.visible !== false );

			if ( layer.visible === false ) {
				continue;
			}

			this.renderLayer( layer );
		}

		// Draw selection indicators after all layers are rendered
		this.drawSelectionIndicators();
		this.debugInfo( '[CanvasManager] renderLayersOptimized completed' );
	};

	/**
	 * Get layers that intersect with dirty regions
	 *
	 * @param {Array} layers - All layers
	 * @param {Array} dirtyRegions - Dirty regions
	 * @return {Array} Layers that need rendering
	 */
	CanvasManager.prototype.getLayersInDirtyRegions = function ( layers, dirtyRegions ) {
		if ( !dirtyRegions || dirtyRegions.length === 0 ) {
			return layers;
		}

		const layersToRender = [];

		layers.forEach( layer => {
			if ( layer.visible === false ) {
				return;
			}

			const layerBounds = this.getLayerBounds( layer );
			if ( !layerBounds ) {
				return;
			}

			// Check if layer intersects with any dirty region
			for ( let i = 0; i < dirtyRegions.length; i++ ) {
				const region = dirtyRegions[ i ];
				if ( this.rectanglesIntersect( layerBounds, region ) ) {
					layersToRender.push( layer );
					break;
				}
			}
		} );

		return layersToRender;
	};

	/**
	 * Check if two rectangles intersect
	 *
	 * @param {Object} rect1 - First rectangle {x, y, width, height}
	 * @param {Object} rect2 - Second rectangle {x, y, width, height}
	 * @return {boolean} True if rectangles intersect
	 */
	CanvasManager.prototype.rectanglesIntersect = function ( rect1, rect2 ) {
		return !( rect1.x + rect1.width < rect2.x ||
			rect2.x + rect2.width < rect1.x ||
			rect1.y + rect1.height < rect2.y ||
			rect2.y + rect2.height < rect1.y );
	};

	/**
	 * Render all layers
	 *
	 * @param {Array} layers - Array of layer objects
	 */
	CanvasManager.prototype.renderLayers = function ( layers ) {
		if ( !layers || layers.length === 0 ) {
			this.debugInfo( '[CanvasManager] renderLayers called with no layers' );
			return;
		}

		this.debugInfo( '[CanvasManager] renderLayers called with', layers.length, 'layers' );
		this.debugInfo( '[CanvasManager] Canvas context available:', !!this.ctx );
		this.debugInfo( '[CanvasManager] Canvas dimensions:', this.canvas ? this.canvas.width + 'x' + this.canvas.height : 'N/A' );

		// Render each layer using appropriate renderer (without additional transformations)
		// Render in reverse order so that layers at the top of the list appear on top
		for ( let i = layers.length - 1; i >= 0; i-- ) {
			const layer = layers[ i ];
			this.debugInfo( '[CanvasManager] Rendering layer', i, ':', layer.type, 'visible:', layer.visible !== false );
			this.debugInfo( '[CanvasManager] Layer', i, 'properties:', {
				id: layer.id,
				x: layer.x,
				y: layer.y,
				width: layer.width,
				height: layer.height,
				radius: layer.radius,
				fill: layer.fill,
				stroke: layer.stroke,
				opacity: layer.opacity,
				rotation: layer.rotation
			} );
			// Fixed: Only skip layer if explicitly set to false (undefined = visible)
			if ( layer.visible === false ) {
				continue;
			}

			this.renderLayer( layer );
		}

		// Draw selection indicators after all layers are rendered
		this.drawSelectionIndicators();
		this.debugInfo( '[CanvasManager] renderLayers completed' );
	};

	/**
	 * Render individual layer
	 * Note: Called within a transformed canvas context (zoom/pan already applied),
	 * so use base/world coordinates without additional scaling.
	 *
	 * @param {Object} layer - Layer object to render (in base/world coordinates)
	 */
	CanvasManager.prototype.renderLayer = function ( layer ) {
		if ( !layer || layer.visible === false || !this.ctx ) {
			return;
		}

		this.debugInfo( '[CanvasManager] renderLayer called for type:', layer.type );

		// Validate layer before rendering
		if ( !this.validateLayerForRendering( layer ) ) {
			this.debugInfo( '[CanvasManager] Layer validation failed, skipping:', layer.id );
			return;
		}

		// Save current state
		this.ctx.save();

		try {
			// Canvas is already transformed (zoom/pan applied in performRedraw)
			// Use base layer coordinates directly - no scaling needed
			// Apply layer-specific transformations (rotation, etc.)
			this.applyLayerTransform( layer );

			// Render the layer using the most appropriate renderer
			if ( this.layerRenderer && this.layerRenderer.supportsType && this.layerRenderer.supportsType( layer.type ) ) {
				this.debugInfo( '[CanvasManager] Using LayerRenderer for', layer.type );
				this.layerRenderer.renderLayer( layer );
			} else if ( this.renderingCore && this.renderingCore.drawLayer ) {
				this.debugInfo( '[CanvasManager] Using RenderingCore for', layer.type );
				this.renderingCore.drawLayer( layer );
			} else {
				// Fallback: Basic layer rendering directly in CanvasManager
				this.debugInfo( '[CanvasManager] Using basic fallback rendering for', layer.type );
				this.renderLayerBasic( layer );
			}

		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Error rendering layer:', error );
			// Try basic rendering as last resort
			try {
				this.renderLayerBasic( layer );
			} catch ( fallbackError ) {
				this.debugInfo( '[CanvasManager] Fallback rendering also failed:', fallbackError );
			}
		} finally {
			// Always restore state
			this.ctx.restore();
		}
	};

	/**
	 * Validate layer data before rendering to prevent corruption
	 *
	 * @param {Object} layer - Layer object to validate
	 * @return {boolean} True if layer is valid for rendering
	 */
	CanvasManager.prototype.validateLayerForRendering = function ( layer ) {
		if ( !layer || typeof layer !== 'object' ) {
			return false;
		}

		// Check required properties
		if ( !layer.type || !layer.id ) {
			return false;
		}

		// Validate coordinates based on layer type
		switch ( layer.type ) {
			case 'text':
			case 'rectangle':
			case 'circle':
			case 'ellipse':
				return typeof layer.x === 'number' && typeof layer.y === 'number' &&
					!isNaN( layer.x ) && !isNaN( layer.y );

			case 'line':
			case 'arrow':
				return typeof layer.x1 === 'number' && typeof layer.y1 === 'number' &&
					typeof layer.x2 === 'number' && typeof layer.y2 === 'number' &&
					!isNaN( layer.x1 ) && !isNaN( layer.y1 ) && !isNaN( layer.x2 ) && !isNaN( layer.y2 );

			case 'polygon':
			case 'path':
				return Array.isArray( layer.points ) && layer.points.length >= 2 &&
					layer.points.every( p => typeof p.x === 'number' && typeof p.y === 'number' &&
						!isNaN( p.x ) && !isNaN( p.y ) );

			default:
				// For unknown types, just check basic position
				return typeof layer.x === 'number' && typeof layer.y === 'number' &&
					!isNaN( layer.x ) && !isNaN( layer.y );
		}
	};

	/**
	 * Apply layer-specific transformations
	 *
	 * @param {Object} layer - Layer object
	 */
	CanvasManager.prototype.applyLayerTransform = function ( layer ) {
		if ( layer.rotation && layer.rotation !== 0 ) {
			// Calculate rotation center
			let centerX = layer.x || 0;
			let centerY = layer.y || 0;

			if ( layer.width && layer.height ) {
				centerX += layer.width / 2;
				centerY += layer.height / 2;
			} else if ( layer.radius ) {
				centerX += layer.radius;
				centerY += layer.radius;
			}

			this.ctx.translate( centerX, centerY );
			this.ctx.rotate( layer.rotation * Math.PI / 180 );
			this.ctx.translate( -centerX, -centerY );
		}

		// Apply layer opacity
		if ( typeof layer.opacity === 'number' && layer.opacity !== 1 ) {
			this.ctx.globalAlpha *= Math.max( 0, Math.min( 1, layer.opacity ) );
		}

		// Apply blend mode
		if ( layer.blendMode || layer.blend ) {
			const blendMode = layer.blendMode || layer.blend;
			if ( this.isValidBlendMode( blendMode ) ) {
				this.ctx.globalCompositeOperation = blendMode;
			}
		}
	};

	/**
	 * Check if a blend mode is valid for canvas
	 *
	 * @param {string} blendMode - Blend mode to check
	 * @return {boolean} True if valid
	 */
	CanvasManager.prototype.isValidBlendMode = function ( blendMode ) {
		const validModes = [
			'source-over', 'source-in', 'source-out', 'source-atop',
			'destination-over', 'destination-in', 'destination-out', 'destination-atop',
			'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken',
			'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light',
			'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'
		];
		return validModes.includes( blendMode );
	};

	/**
	 * Draw a single layer (wrapper for renderLayer for backward compatibility)
	 * Used by ToolManager for temporary layer rendering during drawing operations
	 *
	 * @param {Object} layer - Layer object to draw
	 */
	CanvasManager.prototype.drawLayer = function ( layer ) {
		this.renderLayer( layer );
	};

	/**
	 * Basic layer rendering fallback with improved error handling and state management
	 *
	 * @param {Object} layer - Layer object to render
	 */
	CanvasManager.prototype.renderLayerBasic = function ( layer ) {
		if ( !this.ctx || !layer || layer.visible === false ) {
			return;
		}

		// Save current context state
		this.ctx.save();

		try {
			// Set default values and validate
			const safeLayer = this.sanitizeLayerForRendering( layer );

			// Apply layer-specific styles with validation
			this.applyLayerStyles( safeLayer );

			// Render based on layer type
			switch ( safeLayer.type ) {
				case 'text':
					this.renderTextLayerSafe( safeLayer );
					break;
				case 'rectangle':
					this.renderRectangleLayerSafe( safeLayer );
					break;
				case 'circle':
					this.renderCircleLayerSafe( safeLayer );
					break;
				case 'ellipse':
					this.renderEllipseLayerSafe( safeLayer );
					break;
				case 'line':
					this.renderLineLayerSafe( safeLayer );
					break;
				case 'arrow':
					this.renderArrowLayerSafe( safeLayer );
					break;
				case 'polygon':
					this.renderPolygonLayerSafe( safeLayer );
					break;
				case 'path':
					this.renderPathLayerSafe( safeLayer );
					break;
				default:
					// Basic rectangle fallback for unknown types
					this.renderRectangleLayerSafe( safeLayer );
					break;
			}

		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Error in renderLayerBasic:', error );
			// Reset context to safe state on error
			this.ctx.globalAlpha = 1;
			this.ctx.globalCompositeOperation = 'source-over';
			this.resetCanvasStyles();
		} finally {
			// Always restore context state
			this.ctx.restore();
		}
	};

	/**
	 * Sanitize layer data to prevent rendering corruption
	 *
	 * @param {Object} layer - Layer object to sanitize
	 * @return {Object} Sanitized layer object
	 */
	CanvasManager.prototype.sanitizeLayerForRendering = function ( layer ) {
		const safe = {};

		// Copy and validate basic properties
		safe.type = layer.type || 'rectangle';
		safe.id = layer.id || 'unknown';
		safe.visible = layer.visible !== false;

		// Sanitize coordinates
		safe.x = this.sanitizeNumber( layer.x, 0 );
		safe.y = this.sanitizeNumber( layer.y, 0 );
		safe.width = this.sanitizeNumber( layer.width, 50, 0 );
		safe.height = this.sanitizeNumber( layer.height, 50, 0 );

		// Sanitize line coordinates
		safe.x1 = this.sanitizeNumber( layer.x1, safe.x );
		safe.y1 = this.sanitizeNumber( layer.y1, safe.y );
		safe.x2 = this.sanitizeNumber( layer.x2, safe.x + safe.width );
		safe.y2 = this.sanitizeNumber( layer.y2, safe.y + safe.height );

		// Sanitize radius properties
		safe.radius = this.sanitizeNumber( layer.radius, 25, 0 );
		safe.radiusX = this.sanitizeNumber( layer.radiusX, safe.radius, 0 );
		safe.radiusY = this.sanitizeNumber( layer.radiusY, safe.radius, 0 );

		// Sanitize style properties
		safe.stroke = this.sanitizeColor( layer.stroke || layer.color, '#000000' );
		safe.fill = this.sanitizeColor( layer.fill || layer.color, '#000000' );
		safe.strokeWidth = this.sanitizeNumber( layer.strokeWidth, 1, 0, 100 );
		safe.opacity = this.sanitizeNumber( layer.opacity, 1, 0, 1 );
		safe.fillOpacity = this.sanitizeNumber( layer.fillOpacity, 1, 0, 1 );
		safe.strokeOpacity = this.sanitizeNumber( layer.strokeOpacity, 1, 0, 1 );

		// Sanitize text properties
		safe.text = layer.text ? String( layer.text ).slice( 0, 1000 ) : '';
		safe.fontSize = this.sanitizeNumber( layer.fontSize, 16, 8, 200 );
		safe.fontFamily = this.sanitizeFontFamily( layer.fontFamily );

		// Sanitize transformation properties
		safe.rotation = this.sanitizeNumber( layer.rotation, 0, -360, 360 );

		// Sanitize shadow properties
		safe.shadow = !!layer.shadow;
		if ( safe.shadow ) {
			safe.shadowColor = this.sanitizeColor( layer.shadowColor, '#000000' );
			safe.shadowBlur = this.sanitizeNumber( layer.shadowBlur, 8, 0, 50 );
			safe.shadowOffsetX = this.sanitizeNumber( layer.shadowOffsetX, 2, -50, 50 );
			safe.shadowOffsetY = this.sanitizeNumber( layer.shadowOffsetY, 2, -50, 50 );
		}

		// Sanitize points for polygons/paths
		if ( Array.isArray( layer.points ) ) {
			safe.points = layer.points.slice( 0, 1000 ).map( p => ( {
				x: this.sanitizeNumber( p.x, 0 ),
				y: this.sanitizeNumber( p.y, 0 )
			} ) );
		}

		return safe;
	};

	/**
	 * Sanitize a number value with bounds checking
	 *
	 * @param {*} value - Value to sanitize
	 * @param {number} defaultVal - Default value if invalid
	 * @param {number} min - Minimum allowed value
	 * @param {number} max - Maximum allowed value
	 * @return {number} Sanitized number
	 */
	CanvasManager.prototype.sanitizeNumber = function ( value, defaultVal, min, max ) {
		const num = typeof value === 'number' ? value : parseFloat( value );
		if ( isNaN( num ) || !isFinite( num ) ) {
			return defaultVal;
		}
		if ( typeof min === 'number' && num < min ) {
			return min;
		}
		if ( typeof max === 'number' && num > max ) {
			return max;
		}
		return num;
	};

	/**
	 * Sanitize color value
	 *
	 * @param {string} color - Color to sanitize
	 * @param {string} defaultColor - Default color if invalid
	 * @return {string} Sanitized color
	 */
	CanvasManager.prototype.sanitizeColor = function ( color, defaultColor ) {
		if ( !color || typeof color !== 'string' ) {
			return defaultColor;
		}

		// Allow transparent and none
		if ( color === 'transparent' || color === 'none' ) {
			return color;
		}

		// Basic validation - must start with # for hex or be a named color
		if ( color.match( /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/ ) ||
			color.match( /^(rgb|rgba|hsl|hsla)\s*\([^)]+\)$/ ) ||
			color.match( /^[a-zA-Z]+$/ ) ) {
			return color;
		}

		return defaultColor;
	};

	/**
	 * Sanitize font family
	 *
	 * @param {string} fontFamily - Font family to sanitize
	 * @return {string} Sanitized font family
	 */
	CanvasManager.prototype.sanitizeFontFamily = function ( fontFamily ) {
		if ( !fontFamily || typeof fontFamily !== 'string' ) {
			return 'Arial, sans-serif';
		}

		// Allow common safe fonts
		const safeFonts = [
			'Arial', 'Helvetica', 'Times New Roman', 'Times', 'Courier New', 'Courier',
			'Verdana', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS',
			'Trebuchet MS', 'Arial Black', 'Impact', 'sans-serif', 'serif', 'monospace'
		];

		const requested = fontFamily.split( ',' )[ 0 ].trim().replace( /['"]/g, '' );

		if ( safeFonts.some( safe => safe.toLowerCase() === requested.toLowerCase() ) ) {
			return fontFamily;
		}

		return 'Arial, sans-serif';
	};

	/**
	 * Apply layer styles safely
	 *
	 * @param {Object} layer - Sanitized layer object
	 */
	CanvasManager.prototype.applyLayerStyles = function ( layer ) {
		// Set opacity
		this.ctx.globalAlpha = layer.opacity;

		// Set stroke and fill styles
		this.ctx.strokeStyle = layer.stroke;
		this.ctx.fillStyle = layer.fill;
		this.ctx.lineWidth = layer.strokeWidth;

		// Apply shadow if enabled
		if ( layer.shadow ) {
			this.ctx.shadowColor = layer.shadowColor;
			this.ctx.shadowBlur = layer.shadowBlur;
			this.ctx.shadowOffsetX = layer.shadowOffsetX;
			this.ctx.shadowOffsetY = layer.shadowOffsetY;
		} else {
			// Clear any existing shadow
			this.ctx.shadowColor = 'transparent';
			this.ctx.shadowBlur = 0;
			this.ctx.shadowOffsetX = 0;
			this.ctx.shadowOffsetY = 0;
		}

		// Apply rotation if needed
		if ( layer.rotation && layer.rotation !== 0 ) {
			const centerX = layer.x + ( layer.width || 0 ) / 2;
			const centerY = layer.y + ( layer.height || 0 ) / 2;

			this.ctx.translate( centerX, centerY );
			this.ctx.rotate( layer.rotation * Math.PI / 180 );
			this.ctx.translate( -centerX, -centerY );
		}
	};

	/**
	 * Reset canvas styles to default state
	 */
	CanvasManager.prototype.resetCanvasStyles = function () {
		if ( !this.ctx ) {
			return;
		}

		try {
			this.ctx.globalAlpha = 1;
			this.ctx.globalCompositeOperation = 'source-over';
			this.ctx.strokeStyle = '#000000';
			this.ctx.fillStyle = '#000000';
			this.ctx.lineWidth = 1;
			this.ctx.shadowColor = 'transparent';
			this.ctx.shadowBlur = 0;
			this.ctx.shadowOffsetX = 0;
			this.ctx.shadowOffsetY = 0;
		} catch ( error ) {
			this.debugInfo( '[CanvasManager] Error resetting canvas styles:', error );
		}
	};

	/**
	 * Safe text layer rendering
	 *
	 * @param {Object} layer - Sanitized text layer
	 */
	CanvasManager.prototype.renderTextLayerSafe = function ( layer ) {
		if ( !layer.text ) {
			return;
		}

		this.ctx.font = layer.fontSize + 'px ' + layer.fontFamily;
		this.ctx.textAlign = 'left';
		this.ctx.textBaseline = 'top';

		// Render fill if specified
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.fillOpacity;
			this.ctx.fillStyle = layer.fill;
			this.ctx.fillText( layer.text, layer.x, layer.y );
			this.ctx.globalAlpha = prevAlpha;
		}

		// Render stroke if specified
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' && layer.strokeWidth > 0 ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.strokeOpacity;
			this.ctx.strokeStyle = layer.stroke;
			this.ctx.lineWidth = layer.strokeWidth;
			this.ctx.strokeText( layer.text, layer.x, layer.y );
			this.ctx.globalAlpha = prevAlpha;
		}
	};

	/**
	 * Safe rectangle layer rendering
	 *
	 * @param {Object} layer - Sanitized rectangle layer
	 */
	CanvasManager.prototype.renderRectangleLayerSafe = function ( layer ) {
		// Render fill if specified
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.fillOpacity;
			this.ctx.fillStyle = layer.fill;
			this.ctx.fillRect( layer.x, layer.y, layer.width, layer.height );
			this.ctx.globalAlpha = prevAlpha;
		}

		// Render stroke if specified
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' && layer.strokeWidth > 0 ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.strokeOpacity;
			this.ctx.strokeStyle = layer.stroke;
			this.ctx.lineWidth = layer.strokeWidth;
			this.ctx.strokeRect( layer.x, layer.y, layer.width, layer.height );
			this.ctx.globalAlpha = prevAlpha;
		}
	};

	/**
	 * Safe circle layer rendering
	 *
	 * @param {Object} layer - Sanitized circle layer
	 */
	CanvasManager.prototype.renderCircleLayerSafe = function ( layer ) {
		this.ctx.beginPath();
		this.ctx.arc( layer.x + layer.radius, layer.y + layer.radius, layer.radius, 0, 2 * Math.PI );

		// Render fill if specified
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.fillOpacity;
			this.ctx.fillStyle = layer.fill;
			this.ctx.fill();
			this.ctx.globalAlpha = prevAlpha;
		}

		// Render stroke if specified
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' && layer.strokeWidth > 0 ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.strokeOpacity;
			this.ctx.strokeStyle = layer.stroke;
			this.ctx.lineWidth = layer.strokeWidth;
			this.ctx.stroke();
			this.ctx.globalAlpha = prevAlpha;
		}
	};

	/**
	 * Safe ellipse layer rendering
	 *
	 * @param {Object} layer - Sanitized ellipse layer
	 */
	CanvasManager.prototype.renderEllipseLayerSafe = function ( layer ) {
		this.ctx.beginPath();
		this.ctx.ellipse(
			layer.x + layer.radiusX,
			layer.y + layer.radiusY,
			layer.radiusX,
			layer.radiusY,
			0, 0, 2 * Math.PI
		);

		// Render fill if specified
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.fillOpacity;
			this.ctx.fillStyle = layer.fill;
			this.ctx.fill();
			this.ctx.globalAlpha = prevAlpha;
		}

		// Render stroke if specified
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' && layer.strokeWidth > 0 ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.strokeOpacity;
			this.ctx.strokeStyle = layer.stroke;
			this.ctx.lineWidth = layer.strokeWidth;
			this.ctx.stroke();
			this.ctx.globalAlpha = prevAlpha;
		}
	};

	/**
	 * Safe line layer rendering
	 *
	 * @param {Object} layer - Sanitized line layer
	 */
	CanvasManager.prototype.renderLineLayerSafe = function ( layer ) {
		if ( layer.strokeWidth <= 0 ) {
			return;
		}

		this.ctx.beginPath();
		this.ctx.moveTo( layer.x1, layer.y1 );
		this.ctx.lineTo( layer.x2, layer.y2 );

		this.ctx.strokeStyle = layer.stroke;
		this.ctx.lineWidth = layer.strokeWidth;
		this.ctx.globalAlpha *= layer.strokeOpacity;
		this.ctx.stroke();
	};

	/**
	 * Safe arrow layer rendering
	 *
	 * @param {Object} layer - Sanitized arrow layer
	 */
	CanvasManager.prototype.renderArrowLayerSafe = function ( layer ) {
		if ( layer.strokeWidth <= 0 ) {
			return;
		}

		// Draw the line first
		this.renderLineLayerSafe( layer );

		// Calculate arrow head
		const angle = Math.atan2( layer.y2 - layer.y1, layer.x2 - layer.x1 );
		const headlen = Math.min( 20, Math.sqrt( Math.pow( layer.x2 - layer.x1, 2 ) + Math.pow( layer.y2 - layer.y1, 2 ) ) / 3 );

		// Draw arrow head
		this.ctx.beginPath();
		this.ctx.moveTo( layer.x2, layer.y2 );
		this.ctx.lineTo(
			layer.x2 - headlen * Math.cos( angle - Math.PI / 6 ),
			layer.y2 - headlen * Math.sin( angle - Math.PI / 6 )
		);
		this.ctx.moveTo( layer.x2, layer.y2 );
		this.ctx.lineTo(
			layer.x2 - headlen * Math.cos( angle + Math.PI / 6 ),
			layer.y2 - headlen * Math.sin( angle + Math.PI / 6 )
		);

		this.ctx.strokeStyle = layer.stroke;
		this.ctx.lineWidth = layer.strokeWidth;
		this.ctx.stroke();
	};

	/**
	 * Safe polygon layer rendering
	 *
	 * @param {Object} layer - Sanitized polygon layer
	 */
	CanvasManager.prototype.renderPolygonLayerSafe = function ( layer ) {
		if ( !layer.points || layer.points.length < 3 ) {
			return;
		}

		this.ctx.beginPath();
		this.ctx.moveTo( layer.points[ 0 ].x, layer.points[ 0 ].y );

		for ( let i = 1; i < layer.points.length; i++ ) {
			this.ctx.lineTo( layer.points[ i ].x, layer.points[ i ].y );
		}
		this.ctx.closePath();

		// Render fill if specified
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.fillOpacity;
			this.ctx.fillStyle = layer.fill;
			this.ctx.fill();
			this.ctx.globalAlpha = prevAlpha;
		}

		// Render stroke if specified
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' && layer.strokeWidth > 0 ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.strokeOpacity;
			this.ctx.strokeStyle = layer.stroke;
			this.ctx.lineWidth = layer.strokeWidth;
			this.ctx.stroke();
			this.ctx.globalAlpha = prevAlpha;
		}
	};

	/**
	 * Safe path layer rendering
	 *
	 * @param {Object} layer - Sanitized path layer
	 */
	CanvasManager.prototype.renderPathLayerSafe = function ( layer ) {
		if ( !layer.points || layer.points.length < 2 ) {
			return;
		}

		this.ctx.beginPath();
		this.ctx.moveTo( layer.points[ 0 ].x, layer.points[ 0 ].y );

		for ( let i = 1; i < layer.points.length; i++ ) {
			this.ctx.lineTo( layer.points[ i ].x, layer.points[ i ].y );
		}

		// Render stroke if specified
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' && layer.strokeWidth > 0 ) {
			const prevAlpha = this.ctx.globalAlpha;
			this.ctx.globalAlpha = prevAlpha * layer.strokeOpacity;
			this.ctx.strokeStyle = layer.stroke;
			this.ctx.lineWidth = layer.strokeWidth;
			this.ctx.stroke();
			this.ctx.globalAlpha = prevAlpha;
		}
	};

	/**
	 * Render text layer
	 *
	 * @param {Object} layer - Text layer object
	 */
	CanvasManager.prototype.renderTextLayer = function ( layer ) {
		const text = layer.text || '';
		const x = layer.x || 0;
		const y = layer.y || 0;
		const fontSize = layer.fontSize || 16;
		const fontFamily = layer.fontFamily || 'Arial';
		let prevAlpha;

		this.ctx.font = fontSize + 'px ' + fontFamily;
		this.ctx.textAlign = 'left';
		this.ctx.textBaseline = 'top';

		// Handle fill with fillOpacity
		if ( layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			this.ctx.fillStyle = layer.fill;
			const fillOpacity = ( typeof layer.fillOpacity === 'number' ) ? layer.fillOpacity : 1;
			if ( fillOpacity < 1 ) {
				prevAlpha = this.ctx.globalAlpha;
				this.ctx.globalAlpha = ( prevAlpha || 1 ) * fillOpacity;
				this.ctx.fillText( text, x, y );
				this.ctx.globalAlpha = prevAlpha;
			} else {
				this.ctx.fillText( text, x, y );
			}
		}

		// Handle stroke with strokeOpacity
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' ) {
			this.ctx.strokeStyle = layer.stroke;
			const strokeOpacity = ( typeof layer.strokeOpacity === 'number' ) ? layer.strokeOpacity : 1;
			if ( strokeOpacity < 1 ) {
				prevAlpha = this.ctx.globalAlpha;
				this.ctx.globalAlpha = ( prevAlpha || 1 ) * strokeOpacity;
				this.ctx.strokeText( text, x, y );
				this.ctx.globalAlpha = prevAlpha;
			} else {
				this.ctx.strokeText( text, x, y );
			}
		}
	};

	/**
	 * Render rectangle layer
	 *
	 * @param {Object} layer - Rectangle layer object
	 */
	CanvasManager.prototype.renderRectangleLayer = function ( layer ) {
		const x = layer.x || 0;
		const y = layer.y || 0;
		const width = layer.width || 50;
		const height = layer.height || 50;
		let prevAlpha;

		this.debugInfo( '[CanvasManager] renderRectangleLayer: FIXED - drawing rectangle at (' + x + ', ' + y + ') with size ' + width + 'x' + height + ', fill: ' + layer.fill + ', stroke: ' + layer.stroke );

		// Handle fill with fillOpacity
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			this.ctx.fillStyle = layer.fill;
			const fillOpacity = ( typeof layer.fillOpacity === 'number' ) ? layer.fillOpacity : 1;
			if ( fillOpacity < 1 ) {
				prevAlpha = this.ctx.globalAlpha;
				this.ctx.globalAlpha = ( prevAlpha || 1 ) * fillOpacity;
				this.ctx.fillRect( x, y, width, height );
				this.ctx.globalAlpha = prevAlpha;
			} else {
				this.ctx.fillRect( x, y, width, height );
			}
		}

		// Handle stroke with strokeOpacity
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' ) {
			this.ctx.strokeStyle = layer.stroke;
			if ( layer.strokeWidth ) {
				this.ctx.lineWidth = layer.strokeWidth;
			}
			const strokeOpacity = ( typeof layer.strokeOpacity === 'number' ) ? layer.strokeOpacity : 1;
			if ( strokeOpacity < 1 ) {
				prevAlpha = this.ctx.globalAlpha;
				this.ctx.globalAlpha = ( prevAlpha || 1 ) * strokeOpacity;
				this.ctx.strokeRect( x, y, width, height );
				this.ctx.globalAlpha = prevAlpha;
			} else {
				this.ctx.strokeRect( x, y, width, height );
			}
		}
	};

	/**
	 * Render circle layer
	 *
	 * @param {Object} layer - Circle layer object
	 */
	CanvasManager.prototype.renderCircleLayer = function ( layer ) {
		const x = layer.x || 0;
		const y = layer.y || 0;
		const radius = layer.radius || layer.width / 2 || 25;
		let prevAlpha;

		this.debugInfo( '[CanvasManager] renderCircleLayer: FIXED - drawing circle at center (' + x + ', ' + y + ') with radius', radius, 'fill:', layer.fill, 'stroke:', layer.stroke );

		// Draw circle centered at layer coordinates (x,y)
		this.ctx.beginPath();
		this.ctx.arc( x, y, radius, 0, 2 * Math.PI );

		// Handle fill with fillOpacity
		if ( layer.fill && layer.fill !== 'transparent' && layer.fill !== 'none' ) {
			this.ctx.fillStyle = layer.fill;
			const fillOpacity = ( typeof layer.fillOpacity === 'number' ) ? layer.fillOpacity : 1;
			if ( fillOpacity < 1 ) {
				prevAlpha = this.ctx.globalAlpha;
				this.ctx.globalAlpha = ( prevAlpha || 1 ) * fillOpacity;
				this.ctx.fill();
				this.ctx.globalAlpha = prevAlpha;
			} else {
				this.ctx.fill();
			}
		}

		// Handle stroke with strokeOpacity
		if ( layer.stroke && layer.stroke !== 'transparent' && layer.stroke !== 'none' ) {
			this.ctx.strokeStyle = layer.stroke;
			if ( layer.strokeWidth ) {
				this.ctx.lineWidth = layer.strokeWidth;
			}
			const strokeOpacity = ( typeof layer.strokeOpacity === 'number' ) ? layer.strokeOpacity : 1;
			if ( strokeOpacity < 1 ) {
				prevAlpha = this.ctx.globalAlpha;
				this.ctx.globalAlpha = ( prevAlpha || 1 ) * strokeOpacity;
				this.ctx.stroke();
				this.ctx.globalAlpha = prevAlpha;
			} else {
				this.ctx.stroke();
			}
		}
	};

	/**
	 * Render line layer
	 *
	 * @param {Object} layer - Line layer object
	 */
	CanvasManager.prototype.renderLineLayer = function ( layer ) {
		const x1 = layer.x1 || 0;
		const y1 = layer.y1 || 0;
		const x2 = layer.x2 || ( layer.x1 || 0 ) + ( layer.width || 50 );
		const y2 = layer.y2 || ( layer.y1 || 0 ) + ( layer.height || 0 );

		this.ctx.beginPath();
		this.ctx.moveTo( x1, y1 );
		this.ctx.lineTo( x2, y2 );
		this.ctx.stroke();
	};

	/**
	 * Render arrow layer
	 *
	 * @param {Object} layer - Arrow layer object
	 */
	CanvasManager.prototype.renderArrowLayer = function ( layer ) {
		// First draw the line
		this.renderLineLayer( layer );

		// Then draw arrowhead
		const x1 = layer.x1 || 0;
		const y1 = layer.y1 || 0;
		const x2 = layer.x2 || ( layer.x1 || 0 ) + ( layer.width || 50 );
		const y2 = layer.y2 || ( layer.y1 || 0 ) + ( layer.height || 0 );

		const angle = Math.atan2( y2 - y1, x2 - x1 );
		const arrowSize = layer.arrowSize || 10;

		this.ctx.beginPath();
		this.ctx.moveTo( x2, y2 );
		this.ctx.lineTo(
			x2 - arrowSize * Math.cos( angle - Math.PI / 6 ),
			y2 - arrowSize * Math.sin( angle - Math.PI / 6 )
		);
		this.ctx.moveTo( x2, y2 );
		this.ctx.lineTo(
			x2 - arrowSize * Math.cos( angle + Math.PI / 6 ),
			y2 - arrowSize * Math.sin( angle + Math.PI / 6 )
		);
		this.ctx.stroke();
	};

	/**
	 * Draw selection indicators for selected layers
	 */
	CanvasManager.prototype.drawSelectionIndicators = function () {
		// Check if we have selection data
		if ( !this.selectedLayerId || !this.editor ) {
			return;
		}

		// Get layers from state manager if available
		let layers = [];
		if ( this.editor.stateManager ) {
			layers = this.editor.stateManager.get( 'layers' ) || [];
		} else if ( this.editor.layers ) {
			layers = this.editor.layers;
		}

		// Find the selected layer
		let selectedLayer = null;
		for ( let i = 0; i < layers.length; i++ ) {
			if ( layers[ i ].id === this.selectedLayerId ) {
				selectedLayer = layers[ i ];
				break;
			}
		}

		if ( !selectedLayer ) {
			return;
		}

		// Only draw selection if layer is visible
		if ( selectedLayer.visible !== false ) {
			this.drawBasicSelectionOutline( selectedLayer );
			this.drawSelectionHandlesForLayer( selectedLayer );
		}
	};

	/**
	 * Draw basic selection outline for a layer
	 * Note: This is called within a transformed canvas context, so use base layer coordinates.
	 *
	 * @param {Object} layer - Selected layer (in base/world coordinates)
	 */
	CanvasManager.prototype.drawBasicSelectionOutline = function ( layer ) {
		if ( !this.ctx || !layer ) {
			return;
		}

		this.ctx.save();

		// Use base layer coordinates directly - no scaling needed since canvas is already transformed
		const x = layer.x || 0;
		const y = layer.y || 0;
		const width = layer.width || 50;
		const height = layer.height || 50;

		// Calculate correct rotation center based on layer type
		let centerX, centerY;
		if ( layer.type === 'circle' ) {
			// For circles, rotation center is the center of the circle
			centerX = x;
			centerY = y;
		} else if ( layer.type === 'line' || layer.type === 'arrow' ) {
			// For lines/arrows, rotation center is the midpoint
			const lineX1 = layer.x1 || x;
			const lineY1 = layer.y1 || y;
			const lineX2 = layer.x2 || ( x + width );
			const lineY2 = layer.y2 || ( y + height );
			centerX = ( lineX1 + lineX2 ) / 2;
			centerY = ( lineY1 + lineY2 ) / 2;
		} else {
			// For rectangles and other shapes, rotation center is the center of bounds
			centerX = x + width / 2;
			centerY = y + height / 2;
		}

		// Apply rotation if needed
		if ( layer.rotation ) {
			this.ctx.translate( centerX, centerY );
			this.ctx.rotate( ( layer.rotation || 0 ) * Math.PI / 180 );
			this.ctx.translate( -centerX, -centerY );
		}

		// Set selection outline style (line width inversely scaled with zoom)
		this.ctx.strokeStyle = '#007cba';
		this.ctx.lineWidth = 2 / ( this.zoom || 1 );
		const dashSize = 5 / ( this.zoom || 1 );
		this.ctx.setLineDash( [ dashSize, dashSize ] );
		this.ctx.globalAlpha = 0.8;

		// Declare variables for switch cases
		let radius, selectionRadius, x1, y1, x2, y2, minX, minY, maxX, maxY, selectionPadding;

		// Handle different layer types using base coordinates
		switch ( layer.type ) {
			case 'circle':
				radius = layer.radius || width / 2;
				selectionRadius = radius + 5 / ( this.zoom || 1 );
				this.ctx.beginPath();
				this.ctx.arc( x, y, selectionRadius, 0, 2 * Math.PI );
				this.ctx.stroke();
				break;
			case 'line':
			case 'arrow':
				x1 = layer.x1 || x;
				y1 = layer.y1 || y;
				x2 = layer.x2 || ( x + width );
				y2 = layer.y2 || ( y + height );

				// Draw selection box around line
				minX = Math.min( x1, x2 ) - 5 / ( this.zoom || 1 );
				minY = Math.min( y1, y2 ) - 5 / ( this.zoom || 1 );
				maxX = Math.max( x1, x2 ) + 5 / ( this.zoom || 1 );
				maxY = Math.max( y1, y2 ) + 5 / ( this.zoom || 1 );

				this.ctx.strokeRect( minX, minY, maxX - minX, maxY - minY );
				break;
			default:
				// Rectangle selection for most layer types
				selectionPadding = 2 / ( this.zoom || 1 );
				this.ctx.strokeRect(
					x - selectionPadding,
					y - selectionPadding,
					width + 2 * selectionPadding,
					height + 2 * selectionPadding
				);
				break;
		}

		this.ctx.restore();
	};

	/**
	 * Draw selection handles for a layer
	 * Note: Called within transformed context, use base coordinates.
	 *
	 * @param {Object} layer - Selected layer (in base/world coordinates)
	 */
	CanvasManager.prototype.drawSelectionHandlesForLayer = function ( layer ) {
		if ( !this.ctx || !layer || !this.selectionSystem ) {
			return;
		}

		// Calculate bounds directly from base layer properties without scaling
		// (canvas is already transformed, so use world coordinates)
		let bounds;
		if ( typeof layer.x === 'number' && typeof layer.y === 'number' &&
			typeof layer.width === 'number' && typeof layer.height === 'number' ) {
			bounds = {
				x: layer.x,
				y: layer.y,
				width: layer.width,
				height: layer.height
			};
		} else if ( typeof layer.x1 === 'number' && typeof layer.y1 === 'number' &&
			typeof layer.x2 === 'number' && typeof layer.y2 === 'number' ) {
			// Line/arrow
			const lx1 = Math.min( layer.x1, layer.x2 );
			const ly1 = Math.min( layer.y1, layer.y2 );
			const lx2 = Math.max( layer.x1, layer.x2 );
			const ly2 = Math.max( layer.y1, layer.y2 );
			bounds = { x: lx1, y: ly1, width: lx2 - lx1, height: ly2 - ly1 };
		} else if ( typeof layer.x === 'number' && typeof layer.y === 'number' && layer.radius ) {
			// Circle
			const r = Math.abs( layer.radius );
			bounds = { x: layer.x - r, y: layer.y - r, width: r * 2, height: r * 2 };
		} else {
			return; // Can't determine bounds
		}

		if ( !bounds ) {
			return;
		}

		// Call SelectionSystem to both compute and draw handles in the same pass
		this.selectionSystem.drawSelectionHandles( bounds, layer );
		
		// Synchronize handles from SelectionManager to CanvasManager for hit testing
		if ( this.selectionSystem && this.selectionSystem.selectionHandles ) {
			this.selectionHandles = this.selectionSystem.selectionHandles;
		}
	};

	/**
	 * Select a layer by ID
	 *
	 * @param {string} layerId - ID of the layer to select
	 */
	CanvasManager.prototype.selectLayer = function ( layerId ) {
		this.debugInfo( '[CanvasManager] selectLayer called with layerId:', layerId );
		this.selectedLayerId = layerId;
		
		// Synchronize SelectionManager to ensure selection handles are created
		if ( this.selectionSystem && typeof this.selectionSystem.selectLayer === 'function' ) {
			this.selectionSystem.selectLayer( layerId, false );
			// Synchronize handles for hit testing
			if ( this.selectionSystem.selectionHandles ) {
				this.selectionHandles = this.selectionSystem.selectionHandles;
			}
		}
		
		this.redraw();
	};

	// Mouse event handlers (delegated from EventSystem)

	/**
	 * Get bounding box for a layer in world/base coordinates.
	 * Note: Returns bounds in base coordinate space (not canvas pixel space).
	 * For canvas pixel space bounds, apply transformations manually.
	 *
	 * @param {Object} layer The layer object.
	 * @param {boolean} [isScaled=false] - Deprecated parameter, now ignored.
	 * @returns {Object|null} Bounding box {x, y, width, height} in world coordinates or null.
	 */
	CanvasManager.prototype.getLayerBounds = function ( layer, isScaled ) {
		if ( !layer ) {
			return null;
		}

		// Always use base layer coordinates (no scaling)
		// Common case: rectangular bounds
		if ( typeof layer.x === 'number' && typeof layer.y === 'number' &&
			typeof layer.width === 'number' && typeof layer.height === 'number' ) {
			const minX = Math.min( layer.x, layer.x + layer.width );
			const minY = Math.min( layer.y, layer.y + layer.height );
			return {
				x: minX,
				y: minY,
				width: Math.abs( layer.width ),
				height: Math.abs( layer.height )
			};
		}

		// Line/arrow
		if ( typeof layer.x1 === 'number' && typeof layer.y1 === 'number' &&
			typeof layer.x2 === 'number' && typeof layer.y2 === 'number' ) {
			const lx1 = Math.min( layer.x1, layer.x2 );
			const ly1 = Math.min( layer.y1, layer.y2 );
			const lx2 = Math.max( layer.x1, layer.x2 );
			const ly2 = Math.max( layer.y1, layer.y2 );
			return { x: lx1, y: ly1, width: lx2 - lx1, height: ly2 - ly1 };
		}

		// Ellipse/circle with center + radii
		if ( typeof layer.x === 'number' && typeof layer.y === 'number' &&
			( typeof layer.radius === 'number' ||
				typeof layer.radiusX === 'number' || typeof layer.radiusY === 'number' ) ) {
			const hasRX = ( layer.radiusX !== null && layer.radiusX !== undefined );
			const hasRY = ( layer.radiusY !== null && layer.radiusY !== undefined );
			const rx = Math.abs( hasRX ? layer.radiusX : ( layer.radius || 0 ) );
			const ry = Math.abs( hasRY ? layer.radiusY : ( layer.radius || 0 ) );
			return { x: layer.x - rx, y: layer.y - ry, width: rx * 2, height: ry * 2 };
		}

		// Path/polygon points
		if ( Array.isArray( layer.points ) && layer.points.length ) {
			let minPX = Infinity, minPY = Infinity, maxPX = -Infinity, maxPY = -Infinity;
			for ( let i = 0; i < layer.points.length; i++ ) {
				const p = layer.points[ i ];
				minPX = Math.min( minPX, p.x );
				minPY = Math.min( minPY, p.y );
				maxPX = Math.max( maxPX, p.x );
				maxPY = Math.max( maxPY, p.y );
			}
			return { x: minPX, y: minPY, width: maxPX - minPX, height: maxPY - minPY };
		}

		return null;
	};

	/**
	 * Hit test layers at a given point in world coordinate space.
	 * Both the point and layer bounds are in world/base coordinates.
	 *
	 * @param {Object} point - Point with x, y coordinates in world space.
	 * @return {Object|null} The top-most layer found at the point, or null.
	 */
	CanvasManager.prototype.getLayerAtPoint = function ( point ) {
		const layers = ( this.editor && this.editor.stateManager ) ?
			this.editor.stateManager.get( 'layers' ) || [] :
			( this.editor ? this.editor.layers : [] );

		// Iterate from top layer to bottom (which is reverse of rendering order)
		for ( let i = layers.length - 1; i >= 0; i-- ) {
			const layer = layers[ i ];
			if ( layer.visible === false || layer.locked === true ) {
				continue;
			}

			// Get bounds in world coordinates
			const bounds = this.getLayerBounds( layer );

			if ( bounds &&
				point.x >= bounds.x && point.x <= bounds.x + bounds.width &&
				point.y >= bounds.y && point.y <= bounds.y + bounds.height ) {

				// Enhanced hit-testing for non-rectangular shapes
				// For now, bounding box test is sufficient
				// TODO: Implement precise pixel-perfect hit-testing for complex shapes with rotation
				// - Use point-in-polygon test for polygons/stars
				// - Use distance formula for circles/ellipses
				// - Handle rotation transformations for all shapes
				return layer;
			}
		}

		return null;
	};

	CanvasManager.prototype.handleMouseDown = function ( e, point ) {
		this.debugInfo( '[CanvasManager] handleMouseDown called with point:', point, 'currentTool:', this.currentTool );

		// Determine canvas point when not provided by EventSystem
		const p = point || ( e ? this.getMousePoint( e ) : null );
		if ( !p ) {
			this.debugInfo( '[CanvasManager] No point available for mouse down' );
			return;
		}

		// Middle mouse button (button 1) or space+left click = pan mode
		if ( e && ( e.button === 1 || ( e.button === 0 && this.spacePressed ) ) ) {
			this.debugInfo( '[CanvasManager] Starting pan mode' );
			this.isPanning = true;
			// Store client coordinates for panning (NOT canvas coordinates)
			this.panStartPoint = { clientX: e.clientX, clientY: e.clientY };
			this.canvas.style.cursor = 'grabbing';
			if ( e.button === 1 ) {
				e.preventDefault(); // Prevent middle-click default behavior
			}
			return;
		}

		// Left button only for normal operations
		if ( e && typeof e.button !== 'undefined' && e.button !== 0 ) {
			this.debugInfo( '[CanvasManager] Ignoring non-left mouse button:', e.button );
			return;
		}

		this.debugInfo( '[CanvasManager] Processing mouse down at:', p );

		// If pointer tool and a selection handle is under cursor, start resize
		if ( this.currentTool === 'pointer' && this.selectedLayerId ) {
			const handle = this.hitTestSelectionHandles( p );
			if ( handle ) {
				this.debugInfo( '[CanvasManager] Selection handle hit:', handle );
				this.isResizing = true;
				this.resizeHandle = handle;
				this.resizeStartPoint = { x: p.x, y: p.y };
				return;
			}
		}

		// Hit test layers for selection
		if ( this.currentTool === 'pointer' ) {
			const hitLayer = this.getLayerAtPoint( p );
			if ( hitLayer ) {
				this.debugInfo( '[CanvasManager] Layer hit:', hitLayer.id, hitLayer.type );

				// If clicking on already selected layer, start dragging
				if ( this.selectedLayerId === hitLayer.id ) {
					this.debugInfo( '[CanvasManager] Starting drag for layer:', hitLayer.id );
					this.isDraggingLayer = true;
					this.dragStartPoint = { x: p.x, y: p.y };
					this.dragStateSaved = false;
					this.dragOriginalBounds = this.getLayerBounds( hitLayer );
				} else {
					// Select the layer
					this.editor.selectLayer( hitLayer.id );
				}
			} else {
				this.debugInfo( '[CanvasManager] No layer hit, deselecting all' );
				// Clicked on on empty space - deselect all
				this.editor.selectLayer( null );
			}
		} else {
			// For non-pointer tools, delegate to tool manager to start drawing
			if ( this.toolManager ) {
				this.debugInfo( '[CanvasManager] Delegating to toolManager for tool:', this.currentTool );
				this.toolManager.startTool( p, e );
			} else {
				this.debugInfo( '[CanvasManager] No toolManager available for tool:', this.currentTool );
			}
		}
	};

	CanvasManager.prototype.handleMouseMove = function ( e, point ) {
		// Handle pan operation if in progress - use CLIENT coordinates for panning!
		// Using canvas coordinates creates a feedback loop because they change as we pan
		if ( this.isPanning && this.panStartPoint && this.transformationEngine ) {
			// Get client coordinates directly from event (NOT canvas coordinates)
			const clientX = e ? e.clientX : ( point ? point.x : 0 );
			const clientY = e ? e.clientY : ( point ? point.y : 0 );
			
			// Calculate delta in screen pixels
			const dx = clientX - this.panStartPoint.clientX;
			const dy = clientY - this.panStartPoint.clientY;
			
			// Apply pan delta
			this.transformationEngine.panByPixels( dx, dy );
			this.syncTransformProperties();
			
			// Update pan start point for continuous panning (in client coords)
			this.panStartPoint = { clientX: clientX, clientY: clientY };
			
			// Redraw to show panning
			this.performRedraw( true );
			return;
		}

		// Determine canvas point for all other operations
		const p = point || ( e ? this.getMousePoint( e ) : null );
		if ( !p ) {
			return;
		}

		// Handle resize operation if in progress
		if ( this.isResizing && this.resizeHandle && this.selectedLayerId ) {
			this.handleResizeMove( p );
			return;
		}

		// Handle drag operation if in progress
		if ( this.isDraggingLayer && this.selectedLayerId && this.dragStartPoint ) {
			this.handleDragMove( p );
			return;
		}

		// Update cursor based on what's under the mouse
		this.updateCursorForPosition( p );

		// Delegate to tool manager
		if ( this.toolManager ) {
			this.toolManager.updateTool( p, e );
		}
	};

	CanvasManager.prototype.handleMouseUp = function ( e, point ) {
		// Determine canvas point when not provided by EventSystem
		const p = point || ( e ? this.getMousePoint( e ) : null );
		if ( !p ) {
			return;
		}

		// Finish pan operation if in progress
		if ( this.isPanning ) {
			this.isPanning = false;
			this.panStartPoint = null;
			this.canvas.style.cursor = this.spacePressed ? 'grab' : 'default';
			return;
		}

		// Finish resize operation if in progress
		if ( this.isResizing ) {
			this.finishResize();
			return;
		}

		// Finish drag operation if in progress
		if ( this.isDraggingLayer ) {
			this.finishDrag();
			return;
		}

		// Delegate to tool manager
		if ( this.toolManager ) {
			this.toolManager.finishTool( p, e );
		}
	};

	/**
	 * Handle drag move - updates layer position during drag operation
	 *
	 * @param {Object} point Canvas point {x, y}
	 */
	CanvasManager.prototype.handleDragMove = function ( point ) {
		if ( !this.isDraggingLayer || !this.selectedLayerId || !this.dragStartPoint ) {
			return;
		}

		// Get the selected layer
		const layer = this.editor.stateManager.getLayer( this.selectedLayerId );
		if ( !layer ) {
			return;
		}

		// Calculate delta from drag start
		const dx = point.x - this.dragStartPoint.x;
		const dy = point.y - this.dragStartPoint.y;

		// Update layer position based on original position
		// For circles, x,y is center point, not top-left corner
		let originalX = layer.x || 0;
		let originalY = layer.y || 0;

		// If we saved original bounds at drag start, use those
		if ( this.dragOriginalBounds ) {
			if ( layer.type === 'circle' ) {
				// Circle bounds give top-left, but x,y is center, so compute center from bounds
				originalX = this.dragOriginalBounds.x + this.dragOriginalBounds.width / 2;
				originalY = this.dragOriginalBounds.y + this.dragOriginalBounds.height / 2;
			} else {
				originalX = this.dragOriginalBounds.x;
				originalY = this.dragOriginalBounds.y;
			}
		}

		// Apply updates to layer via state manager
		this.editor.stateManager.updateLayer( this.selectedLayerId, {
			x: originalX + dx,
			y: originalY + dy
		} );

		// Request redraw
		this.performRedraw( true );
	};

	/**
	 * Finish drag operation - completes layer dragging
	 */
	CanvasManager.prototype.finishDrag = function () {
		if ( !this.isDraggingLayer ) {
			return;
		}

		// Reset drag state
		this.isDraggingLayer = false;
		this.dragStartPoint = null;
		this.dragStateSaved = false;
		this.dragOriginalBounds = null;

		// Final redraw
		this.performRedraw( true );
	};

	/**
	 * Handle resize move - updates layer size during resize operation
	 *
	 * @param {Object} point Canvas point {x, y}
	 */
	CanvasManager.prototype.handleResizeMove = function ( point ) {
		if ( !this.isResizing || !this.resizeHandle || !this.selectedLayerId || !this.resizeStartPoint ) {
			return;
		}

		// Get the selected layer
		const layer = this.editor.stateManager.getLayer( this.selectedLayerId );
		if ( !layer ) {
			return;
		}

		// Calculate delta from resize start
		const dx = point.x - this.resizeStartPoint.x;
		const dy = point.y - this.resizeStartPoint.y;

		// Store original layer state if not already saved
		if ( !this.resizeStateSaved ) {
			this.originalLayer = Object.assign( {}, layer );
			this.resizeStateSaved = true;
		}

		// Calculate new dimensions based on handle position
		const updates = {};
		// Extract handle type string (handle is an object with type property)
		const handleType = this.resizeHandle.type || this.resizeHandle;

		// Handle rotation separately (just update rotation angle, don't change size)
		// Skip rotation for circles - they are radially symmetric, so rotation is meaningless
		if ( handleType === 'rotate' && layer.type !== 'circle' ) {
			// Calculate angle from layer center to current point
			const centerX = this.originalLayer.x || 0;
			const centerY = this.originalLayer.y || 0;
			const angle = Math.atan2( point.y - centerY, point.x - centerX );
			// Convert to degrees
			const rotation = ( angle * 180 / Math.PI ) - 90; // -90 to make 0 point up
			updates.rotation = rotation;
		} else if ( layer.type === 'circle' ) {
			// For circles, resize by adjusting radius
			// Calculate average delta for uniform scaling
			const avgDelta = ( Math.abs( dx ) + Math.abs( dy ) ) / 2;
			const deltaSign = ( dx + dy ) >= 0 ? 1 : -1;
			const radiusChange = avgDelta * deltaSign;
			
			// Get original radius (default to 50 if not set)
			const originalRadius = this.originalLayer.radius || 50;
			updates.radius = Math.max( 10, originalRadius + radiusChange );
		} else if ( layer.type === 'ellipse' ) {
			// For ellipses, resize by adjusting radiusX and radiusY
			const originalRadiusX = this.originalLayer.radiusX || this.originalLayer.radius || 50;
			const originalRadiusY = this.originalLayer.radiusY || this.originalLayer.radius || 30;
			
			// Handle corner and edge resizing
			if ( handleType.includes( 'n' ) || handleType.includes( 's' ) ) {
				const radiusYChange = handleType.includes( 'n' ) ? -dy : dy;
				updates.radiusY = Math.max( 10, originalRadiusY + radiusYChange );
			}
			if ( handleType.includes( 'w' ) || handleType.includes( 'e' ) ) {
				const radiusXChange = handleType.includes( 'w' ) ? -dx : dx;
				updates.radiusX = Math.max( 10, originalRadiusX + radiusXChange );
			}
		} else {
			// For rectangular shapes (rectangle, text, etc.), use width/height
			// Handle corner and edge resizing based on handle type
			if ( handleType.includes( 'n' ) ) {
				updates.y = this.originalLayer.y + dy;
				updates.height = Math.max( 10, this.originalLayer.height - dy );
			}
			if ( handleType.includes( 's' ) ) {
				updates.height = Math.max( 10, this.originalLayer.height + dy );
			}
			if ( handleType.includes( 'w' ) ) {
				updates.x = this.originalLayer.x + dx;
				updates.width = Math.max( 10, this.originalLayer.width - dx );
			}
			if ( handleType.includes( 'e' ) ) {
				updates.width = Math.max( 10, this.originalLayer.width + dx );
			}
		}

		// Apply updates to layer via state manager
		this.editor.stateManager.updateLayer( this.selectedLayerId, updates );

		// Update selection handles to reflect new size/rotation
		// IMPORTANT: Call this AFTER updateLayer so handles use updated layer data
		if ( this.selectionManager && typeof this.selectionManager.updateSelectionHandles === 'function' ) {
			this.selectionManager.updateSelectionHandles();
		}

		// Request full redraw to show updated layer and handles
		this.redraw();
	};

	/**
	 * Finish resize operation - completes layer resizing
	 */
	CanvasManager.prototype.finishResize = function () {
		if ( !this.isResizing ) {
			return;
		}

		// Reset resize state
		this.isResizing = false;
		this.resizeHandle = null;
		this.resizeStartPoint = null;
		this.resizeStateSaved = false;
		this.originalLayer = null;

		// Final redraw
		this.performRedraw( true );
	};

	/**
	 * Update cursor based on what's under the mouse position
	 *
	 * @param {Object} point Canvas point {x, y}
	 */
	CanvasManager.prototype.updateCursorForPosition = function ( point ) {
		// Default to tool cursor
		let cursor = 'default';

		// Check if we're over a selection handle
		if ( this.currentTool === 'pointer' && this.selectedLayerId ) {
			const handle = this.hitTestSelectionHandles( point );
			if ( handle ) {
				// Set cursor based on handle type/position
				cursor = this.getCursorForHandle( handle );
			} else {
				// Check if we're over the selected layer itself
				const hitLayer = this.getLayerAtPoint( point );
				if ( hitLayer && hitLayer.id === this.selectedLayerId ) {
					cursor = 'move';
				} else if ( this.toolManager ) {
					// Use tool's default cursor
					cursor = this.toolManager.getToolCursor( this.currentTool );
				}
			}
		} else if ( this.toolManager ) {
			// Use tool's default cursor
		
			cursor = this.toolManager.getToolCursor( this.currentTool );
		}

		// Apply cursor to canvas
		this.canvas.style.cursor = cursor;
	};

	/**
	 * Get appropriate cursor for a selection handle
	 *
	 * @param {Object} handle Handle object with type and position info
	 * @return {string} CSS cursor value
	 */
	CanvasManager.prototype.getCursorForHandle = function ( handle ) {
		if ( !handle || !handle.type ) {
			return 'default';
		}

		// Map handle types to cursors
		switch ( handle.type ) {
			case 'nw':
			case 'se':
				return 'nw-resize';
			case 'ne':
			case 'sw':
				return 'ne-resize';
			case 'n':
			case 's':
				return 'ns-resize';
			case 'e':
			case 'w':
				return 'ew-resize';
			case 'rotate':
				return 'crosshair';
			default:
				return 'move';
		}
	};

	CanvasManager.prototype.handleDoubleClick = function ( e, point ) {
		// Determine canvas point when not provided by EventSystem
		const p = point || ( e ? this.getMousePoint( e ) : null );
		if ( !p ) {
			return;
		}

		// Double-click to edit text layers
		if ( this.currentTool === 'pointer' ) {
			const hitLayer = this.getLayerAtPoint( p );
			if ( hitLayer && hitLayer.type === 'text' ) {
				// Switch to text tool and start editing
				this.setTool( 'text' );
				if ( this.toolManager ) {
					this.toolManager.startTextTool( p, hitLayer );
				}
			}
		}
	};

	// Pointer-based event methods (preferred by EventHandler)
	CanvasManager.prototype.handlePointerDown = function ( x, y ) {
		const point = { x: x, y: y };
		this.handleMouseDown( null, point );
	};

	CanvasManager.prototype.handlePointerMove = function ( x, y ) {
		const point = { x: x, y: y };
this.handleMouseMove( null, point );
	};

	CanvasManager.prototype.handlePointerUp = function ( x, y ) {
		const point = { x: x, y: y };
		this.handleMouseUp( null, point );
	};

	CanvasManager.prototype.handleWheel = function ( e ) {
		// Delegate to TransformationEngine for zoom with mouse position as anchor
		if ( this.transformationEngine ) {
			e.preventDefault();
			const delta = e.deltaY;
			const zoomDelta = delta > 0 ? -0.1 : 0.1; // Negative for zoom out, positive for zoom in

			// Get mouse position as anchor point for zoom
			const mousePoint = this.eventSystem.getEventCoordinates( e );
			this.transformationEngine.zoomBy( zoomDelta, mousePoint );

			// Sync properties after zoom change
			this.syncTransformProperties();

			// Trigger immediate redraw
			this.redraw();
		}
	};

	CanvasManager.prototype.handleKeyDown = function ( e ) {
		// Don't handle keys when typing in input fields
		if ( e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true' ) {
			return;
		}

		// Handle keyboard shortcuts
		if ( e.ctrlKey || e.metaKey ) {
			switch ( e.key.toLowerCase() ) {
				case 'a':
					e.preventDefault();
					this.selectAll();
					break;
				case 'd':
					e.preventDefault();
					this.deselectAll();
					break;
				case 'c':
					e.preventDefault();
					this.copySelected();
					break;
				case 'v':
					e.preventDefault();
					this.pasteFromClipboard();
					break;
				case 'x':
					e.preventDefault();
					this.cutSelected();
					break;
				case 'z':
					e.preventDefault();
					if ( e.shiftKey ) {



						this.redo();
					} else {
						this.undo();
					}
					break;
				case '=':
				case '+':
					e.preventDefault();
					this.zoomIn();
					break;
				case '-':
					e.preventDefault();
					this.zoomOut();
					break;
				case '0':
					e.preventDefault();
					this.resetZoom();
					break;
			}
		}

		// Delete selected objects
		if ( e.key === 'Delete' || e.key === 'Backspace' ) {
			e.preventDefault();
			this.deleteSelected();
		}

		// Pan shortcuts with arrow keys (delegate to TransformationEngine)
		if ( !e.ctrlKey && !e.metaKey && this.transformationEngine ) {
			const panDistance = 20;
			switch ( e.key ) {
				case 'ArrowUp':
					e.preventDefault();

					this.transformationEngine.panByPixels( 0, panDistance );
					this.syncTransformProperties();
					break;
				case 'ArrowDown':
					e.preventDefault();
					this.transformationEngine.panByPixels( 0, -panDistance );
					this.syncTransformProperties();
					break;
				case 'ArrowLeft':
					e.preventDefault();
					this.transformationEngine.panByPixels( panDistance, 0 );
					this.syncTransformProperties();
					break;
				case 'ArrowRight':
					e.preventDefault();
					this.transformationEngine.panByPixels( -panDistance, 0 );
					this.syncTransformProperties();
					break;
			}
		}

		// Space key for temporary pan mode
		if ( e.code === 'Space' && !e.repeat ) {
			e.preventDefault();
			this.spacePressed = true;
			this.canvas.style.cursor = 'grab';
		}
	};

	CanvasManager.prototype.handleKeyUp = function ( e ) {
		// Handle key up events
		if ( e.code === 'Space' ) {
			this.spacePressed = false;
			this.canvas.style.cursor = this.getToolCursor( this.currentTool );
		}
	};

	/**
	 * Set the current tool
	 * @param {string} tool - Tool name
	 */
	CanvasManager.prototype.setTool = function ( tool ) {
		this.currentTool = tool;
		// Also update ToolManager to keep them in sync
		if ( this.toolManager && typeof this.toolManager.setTool === 'function' ) {
			this.toolManager.setTool( tool );
		}
		// eslint-disable-next-line no-console
		console.info( '[CanvasManager] setTool: Tool changed to', tool );
	};

	/**
	 * Get cursor for current tool
	 *
	 * @param {string} tool - Tool name
	 * @return {string} CSS cursor value
	 */
	CanvasManager.prototype.getToolCursor = function ( tool ) {
		switch ( tool ) {
			case 'pointer':
				return 'default';
			case 'pan':
				return 'grab';
			case 'text':
				return 'text';
			case 'blur':
				return 'crosshair';
			case 'pen':
				return 'crosshair';
			case 'rectangle':
			case 'circle':
			case 'ellipse':
			case 'polygon':
			case 'star':
			case 'line':
			case 'arrow':
			case 'highlight':
			case 'path':
				return 'crosshair';
			default:
				return 'crosshair';
		}
	};

	/**
	 * Basic background image drawing fallback
	 * Note: This method is called within a transformed canvas context (after zoom/pan applied)
	 * so it should draw in world coordinates, not canvas pixel coordinates.
	 *
	 * @param {Image} img The image element to draw
	 */
	CanvasManager.prototype.drawBackgroundImageBasic = function ( img ) {
		if ( !this.ctx || !img ) {
			// eslint-disable-next-line no-console
			console.warn( '[CanvasManager] drawBackgroundImageBasic: No context or image available' );
			return;
		}

		// eslint-disable-next-line no-console
		console.info( '[CanvasManager] drawBackgroundImageBasic: Drawing image', img.naturalWidth + 'x' + img.naturalHeight );

		try {
			// Use base dimensions if available (world coordinate size)
			const imgWidth = this.baseWidth || img.naturalWidth;
			const imgHeight = this.baseHeight || img.naturalHeight;

			// Draw image at world origin (0, 0) with base dimensions
			// Canvas transformations (zoom/pan) are already applied in performRedraw
			this.ctx.drawImage( img, 0, 0, imgWidth, imgHeight );

			// Store the world-space rect for hit testing
			this.backgroundImageRect = { x: 0, y: 0, width: imgWidth, height: imgHeight };

			// eslint-disable-next-line no-console
			console.info( '[CanvasManager] drawBackgroundImageBasic: Successfully drew background image at (0,0) with size', imgWidth + 'x' + imgHeight );
		} catch ( e ) {
			// eslint-disable-next-line no-console
			console.error( '[CanvasManager] drawBackgroundImageBasic: Error drawing background image:', e );
		}
	};

	/**
	 * Draw a grid on the canvas
	 */
	CanvasManager.prototype.drawGrid = function () {
		if ( !this.ctx || !this.showGrid ) {
			return;
		}

		this.ctx.save();
		this.ctx.strokeStyle = this.gridColor;
		this.ctx.lineWidth = 0.5 / ( this.zoom || 1 );

		const gridSize = this.gridSize;
		const width = this.canvas.width;
		const height = this.canvas.height;

		// Draw vertical lines
		for ( let x = 0; x <= width; x += gridSize ) {
			this.ctx.beginPath();
			this.ctx.moveTo( x, 0 );
			this.ctx.lineTo( x, height );
			this.ctx.stroke();
		}

		// Draw horizontal lines
		for ( let y = 0; y <= height; y += gridSize ) {
			this.ctx.beginPath();
			this.ctx.moveTo( 0, y );
			this.ctx.lineTo( width, y );
			this.ctx.stroke();
		}

		this.ctx.restore();
	};

	/**
	 * Draw rulers on the canvas
	 */
	CanvasManager.prototype.drawRulers = function () {
		if ( !this.ctx || !this.showRulers ) {
			return;
		}

		this.ctx.save();
		this.ctx.strokeStyle = this.rulerColor;
		this.ctx.lineWidth = 1 / ( this.zoom || 1 );

		const rulerSize = this.rulerSize;
		const width = this.canvas.width;
		const height = this.canvas.height;

		// Draw top ruler
		this.ctx.beginPath();
		this.ctx.moveTo( 0, rulerSize );
		this.ctx.lineTo( width, rulerSize );
		this.ctx.stroke();

		// Draw left ruler
		this.ctx.beginPath();
		this.ctx.moveTo( rulerSize, 0 );
		this.ctx.lineTo( rulerSize, height );
		this.ctx.stroke();

		this.ctx.restore();
	};

	/**
	 * Draw guides on the canvas
	 */
	CanvasManager.prototype.drawGuides = function ( hGuides, vGuides ) {
		if ( !this.ctx || ( !hGuides && !vGuides ) ) {
			return;
		}

		this.ctx.save();
		this.ctx.strokeStyle = '#ff0000';
		this.ctx.lineWidth = 1 / ( this.zoom || 1 );

		// Draw horizontal guides
		if ( hGuides ) {
			hGuides.forEach( ( y ) => {
				this.ctx.beginPath();
				this.ctx.moveTo( 0, y );
				this.ctx.lineTo( this.canvas.width, y );
				this.ctx.stroke();
			} );
		}

		// Draw vertical guides
		if ( vGuides ) {
			vGuides.forEach( ( x ) => {
				this.ctx.beginPath();
				this.ctx.moveTo( x, 0 );
				this.ctx.lineTo( x, this.canvas.height );
				this.ctx.stroke();
			} );
		}

		this.ctx.restore();
	};

	/**
	 * Clean up all resources and event listeners
	 */
	CanvasManager.prototype.dispose = function () {
		// Prevent multiple dispose calls
		if ( this.isDisposed ) {
			return;
		}
		this.isDisposed = true;

		// Cancel any pending animation frames
		if ( this.animationFrameId ) {
			cancelAnimationFrame( this.animationFrameId );
			this.animationFrameId = null;
		}

		// Cancel any pending timeouts
		if ( this.redrawTimeout ) {
			clearTimeout( this.redrawTimeout );
			this.redrawTimeout = null;
		}

		// Clean up canvas event listeners
		this.cleanupCanvasEventListeners();

		// Dispose of all module instances
		if ( this.eventSystem && typeof this.eventSystem.destroy === 'function' ) {
			this.eventSystem.destroy();
		}

		if ( this.selectionSystem && typeof this.selectionSystem.destroy === 'function' ) {
			this.selectionSystem.destroy();
		}

		if ( this.transformationEngine && typeof this.transformationEngine.destroy === 'function' ) {
			this.transformationEngine.destroy();
		}

		if ( this.toolManager && typeof this.toolManager.destroy === 'function' ) {
			this.toolManager.destroy();
		}

		if ( this.renderingCore && typeof this.renderingCore.destroy === 'function' ) {
			this.renderingCore.destroy();
		}

		if ( this.layerRenderer && typeof this.layerRenderer.destroy === 'function' ) {
			this.layerRenderer.destroy();
		}

		// Clear canvas and context
		if ( this.ctx ) {
			this.ctx.clearRect( 0, 0, this.canvas.width, this.canvas.height );
		}

		// Clear canvas pool
		this.tempCanvasPool.forEach( function( canvas ) {
			if ( canvas && canvas.getContext ) {
				const ctx = canvas.getContext( '2d' );
				if ( ctx ) {
					ctx.clearRect( 0, 0, canvas.width, canvas.height );
				}
			}
		} );
		this.tempCanvasPool = [];

		// Clear caches
		if ( this.layersCache ) {
			Object.keys( this.layersCache ).forEach( function( key ) {
				delete this.layersCache[ key ];
			}.bind( this ) );
		}

		// Clear arrays
		if ( this.dirtyRegions ) {
			this.dirtyRegions.length = 0;
		}
		if ( this.history ) {
			this.history.length = 0;
		}
		if ( this.clipboard ) {
			this.clipboard.length = 0;
		}
		if ( this.selectionHandles ) {
			this.selectionHandles.length = 0;
		}
		if ( this.horizontalGuides ) {
			this.horizontalGuides.length = 0;
		}
		if ( this.verticalGuides ) {
			this.verticalGuides.length = 0;
		}

		// Clear all object references
		this.canvas = null;
		this.ctx = null;
		this.container = null;
		this.editor = null;
		this.config = null;
		this.backgroundImage = null;
		this.renderingCore = null;
		this.layerRenderer = null;
		this.transformationEngine = null;
		this.eventSystem = null;
		this.selectionSystem = null;
		this.selectionManager = null;
		this.toolManager = null;
		this.clipboard = null;
		this.selectionHandles = null;
		this.rotationHandle = null;
		this.history = null;
		this.layersCache = null;
		this.dirtyRegions = null;
		this.horizontalGuides = null;
		this.verticalGuides = null;

		// Reset state flags
		this.redrawScheduled = false;
		this.isDraggingLayer = false;
		this.isResizing = false;
		this.isPanning = false;
		this.dragPreview = false;
		this.showDragGhost = false;
		this.isDraggingGuide = false;
		this.transformEventScheduled = false;
		this.isInitialized = false;
	};

	/**
	 * Clean up canvas event listeners to prevent memory leaks
	 */
	CanvasManager.prototype.cleanupCanvasEventListeners = function () {
		if ( !this.canvas ) {
			return;
		}

		// Remove all event listeners by cloning the canvas
		// This is the most reliable way to remove all listeners
		const newCanvas = this.canvas.cloneNode( true );
		
		// Copy important attributes
		newCanvas.width = this.canvas.width;
		newCanvas.height = this.canvas.height;
		newCanvas.style.cssText = this.canvas.style.cssText;
		
		// Replace the old canvas with the new one
		if ( this.canvas.parentNode ) {
			this.canvas.parentNode.replaceChild( newCanvas, this.canvas );
			this.canvas = newCanvas;
			this.ctx = newCanvas.getContext( '2d' );
		}
	};

	/**
	 * Alias for dispose (for backward compatibility)
	 */
	CanvasManager.prototype.destroy = function () {
		this.dispose();
	};

	// Export for MediaWiki ResourceLoader and tests:
	// attach to both module.exports and window when available
	/**
	 * Draw selection handles for a layer
	 * @param {Object} bounds - Layer bounds {x, y, width, height}
	 * @param {Object} layer - Layer object
	 */
	CanvasManager.prototype.drawSelectionHandles = function ( bounds, layer ) {
		if ( !layer ) {
			return;
		}

		this.selectionHandles = [];

		const handleSize = 8;
		const halfSize = handleSize / 2;

		// Use getLayerBounds for consistent coordinate system with hit testing
		const layerBounds = this.getLayerBounds( layer );

		// Define handle positions relative to layer bounds (world coordinates)
		// These are center points of the handles
		const positions = [
			{ type: 'nw', x: layerBounds.x, y: layerBounds.y },
			{ type: 'n', x: layerBounds.x + layerBounds.width / 2, y: layerBounds.y },
			{ type: 'ne', x: layerBounds.x + layerBounds.width, y: layerBounds.y },
			{ type: 'e', x: layerBounds.x + layerBounds.width, y: layerBounds.y + layerBounds.height / 2 },
			{ type: 'se', x: layerBounds.x + layerBounds.width, y: layerBounds.y + layerBounds.height },
			{ type: 's', x: layerBounds.x + layerBounds.width / 2, y: layerBounds.y + layerBounds.height },
			{ type: 'sw', x: layerBounds.x, y: layerBounds.y + layerBounds.height },
			{ type: 'w', x: layerBounds.x, y: layerBounds.y + layerBounds.height / 2 }
		];

		// Add rotation handle above the top center (skip for circles - they're radially symmetric)
		if ( layer.type !== 'circle' ) {
			positions.push( {
				type: 'rotate',
				x: layerBounds.x + layerBounds.width / 2,
				y: layerBounds.y - 20
			} );
		}

		// Apply rotation if layer has rotation
		if ( layer.rotation && layer.rotation !== 0 ) {
			const centerX = layerBounds.x + layerBounds.width / 2;
			const centerY = layerBounds.y + layerBounds.height / 2;
			const angle = layer.rotation * Math.PI / 180;
			const cos = Math.cos( angle );
			const sin = Math.sin( angle );

			positions.forEach( pos => {
				// Calculate the position relative to center
				const relX = pos.x - centerX;
				const relY = pos.y - centerY;

				// Rotate the position
				pos.x = centerX + relX * cos - relY * sin;
				pos.y = centerY + relX * sin + relY * cos;
			} );
		}

		// Store the final handle positions (including rotation adjustments)
		// Store handle center positions with type
		this.selectionHandles = positions.map( pos => ( {
			type: pos.type,
			x: pos.x,
			y: pos.y,
			size: handleSize
		} ) );
	};

	/**
	 * Test if a point hits any selection handle
	 * @param {Object} point - Point to test {x, y} in world coordinates
	 * @return {Object|null} Handle info if hit, null otherwise
	 */
	CanvasManager.prototype.hitTestSelectionHandles = function ( point ) {
		if ( !this.selectionHandles || !point ) {
			return null;
		}

		// Test against each handle using center point and size
		for ( const handle of this.selectionHandles ) {
			const handleSize = handle.size || 8;
			const halfSize = handleSize / 2;
			
			// Test if point is within handle bounds (handle.x and handle.y are centers)
			if ( point.x >= handle.x - halfSize && point.x <= handle.x + halfSize &&
				point.y >= handle.y - halfSize && point.y <= handle.y + halfSize ) {
				return handle;
			}
		}

		return null;
	};

	/**
	 * Update canvas transformation matrix
	 */
	CanvasManager.prototype.updateCanvasTransform = function () {
		if ( !this.ctx ) {
			return;
		}

		// Reset transform
		this.ctx.setTransform( 1, 0, 0, 1, 0, 0 );

		// Apply pan and zoom
		this.ctx.translate( this.panX || 0, this.panY || 0 );
		this.ctx.scale( this.zoom || 1, this.zoom || 1 );

		// Mark transform as changed for dirty region optimization
		this.transformChanged = true;
	};

	/**
	 * Convert client coordinates to canvas coordinates
	 * @param {number} clientX - Client X coordinate
	 * @param {number} clientY - Client Y coordinate
	 * @return {Object} Canvas coordinates {x, y}
	 */
	CanvasManager.prototype.getMousePointFromClient = function ( clientX, clientY ) {
		if ( !this.canvas ) {
			return { x: clientX, y: clientY };
		}

		const rect = this.canvas.getBoundingClientRect();
		const scaleX = this.canvas.width / rect.width;
		const scaleY = this.canvas.height / rect.height;

		// Convert client coordinates to canvas coordinates
		const canvasX = ( clientX - rect.left ) * scaleX;
		const canvasY = ( clientY - rect.top ) * scaleY;

		// Apply inverse transformation (pan and zoom)
		const zoom = this.zoom || 1;
		const panX = this.panX || 0;
		const panY = this.panY || 0;

		return {
			x: ( canvasX - panX ) / zoom,
			y: ( canvasY - panY ) / zoom
		};
	};

	/**
	 * Get mouse point from mouse event
	 * @param {MouseEvent} e - Mouse event
	 * @return {Object} Canvas coordinates {x, y}
	 */
	CanvasManager.prototype.getMousePoint = function ( e ) {
		if ( !e ) {
			return { x: 0, y: 0 };
		}
		return this.getMousePointFromClient( e.clientX, e.clientY );
	};

	/**
	 * Toggle grid visibility
	 */
	CanvasManager.prototype.toggleGrid = function () {
		this.showGrid = !this.showGrid;
		this.performRedraw();
	};

	/**
	 * Toggle rulers visibility
	 */
	CanvasManager.prototype.toggleRulers = function () {
		this.showRulers = !this.showRulers;
		this.performRedraw();
	};

	/**
	 * Toggle guides visibility
	 */
	CanvasManager.prototype.toggleGuidesVisibility = function () {
		this.showGuides = !this.showGuides;
		this.performRedraw();
	};

	/**
	 * Toggle snap to grid
	 */
	CanvasManager.prototype.toggleSnapToGrid = function () {
		this.snapToGrid = !this.snapToGrid;
		// No redraw needed for snap settings
	};

	/**
	 * Toggle snap to guides
	 */
	CanvasManager.prototype.toggleSnapToGuides = function () {
		this.snapToGuides = !this.snapToGuides;
		// No redraw needed for snap settings
	};

	/**
	 * Zoom by a delta amount anchored at a specific canvas point
	 * @param {number} delta - Zoom delta (+ for zoom in, - for zoom out)
	 * @param {Object} anchor - Anchor point {x, y} in canvas coordinates
	 */
	CanvasManager.prototype.zoomBy = function ( delta, anchor ) {
		if ( !anchor ) {
			return;
		}

		const oldZoom = this.zoom || 1;
		const requestedZoom = oldZoom + delta;

		// Use instance min/max zoom if set, otherwise use defaults
		const minZoom = this.minZoom || 0.1;
		const maxZoom = this.maxZoom || 5.0;
		const clampedZoom = Math.max( minZoom, Math.min( maxZoom, requestedZoom ) );

		if ( clampedZoom === oldZoom ) {
			return; // No change
		}

		// Calculate new pan to keep anchor point fixed at its current screen position
		// screenPosition = currentPan + currentZoom * anchor
		// To maintain: newPan + newZoom * anchor = screenPosition
		// So: newPan = screenPosition - newZoom * anchor
		const screenX = this.panX + oldZoom * anchor.x;
		const screenY = this.panY + oldZoom * anchor.y;

		this.panX = screenX - clampedZoom * anchor.x;
		this.panY = screenY - clampedZoom * anchor.y;

		this.zoom = clampedZoom;
		this.userHasSetZoom = true;

		// Update canvas transform
		this.updateCanvasTransform();

		// Emit zoom change event
		if ( this.editor && typeof this.editor.emit === 'function' ) {
			this.editor.emit( 'zoomChanged', { zoom: clampedZoom, panX: this.panX, panY: this.panY } );
		}
	};

	if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = CanvasManager;
	}
	if ( typeof window !== 'undefined' ) {
		window.CanvasManager = CanvasManager;
	}

	// MediaWiki ResourceLoader support
	if ( typeof mw !== 'undefined' && mw.loader ) {
		mw.loader.using( [], () => {
			mw.CanvasManager = CanvasManager;
		} );
	}

}() );
